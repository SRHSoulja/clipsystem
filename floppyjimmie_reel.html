<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FloppyJimmie Away Reel</title>

  <!-- Transition preloading is handled in JS - supports video (preferred) or GIF fallback -->
  <link rel="preload" as="video" href="/flop/transition.mp4" fetchpriority="high">
  <link rel="preload" as="video" href="/flop/transition.webm" fetchpriority="high">
  <link rel="preload" as="image" href="/flop/transition.gif" fetchpriority="high">

  <link rel="dns-prefetch" href="//clips.twitch.tv">
  <link rel="preconnect" href="https://clips.twitch.tv" crossorigin>
  <link rel="preconnect" href="https://gql.twitch.tv" crossorigin>
  <link rel="preconnect" href="https://static.twitchcdn.net" crossorigin>

  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    .stage { position: relative; width: 100%; height: 100%; overflow: hidden; }

    .viewport{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      z-index:1;
      background:#000;
    }

    .viewport .frameWrap{
      position:absolute;
      inset:0;
    }

    .viewport iframe{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      border:0;
      opacity:0;
      transition: opacity 820ms linear;
    }
    .viewport iframe.live{ opacity:1; }

    body.overscan .viewport iframe{
      transform: scale(1.08) translateY(-3%);
      transform-origin:center;
    }

    body.fakeMobile .viewport .frameWrap{
      width: 1500px;
      height: 1080px;
      inset: auto;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(var(--embed-scale, 1));
      transform-origin: center;
    }

    body.fakeMobile.overscan .viewport iframe{
      transform: none;
    }

    #transition{
      position:absolute;
      inset:0;
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:1;
      pointer-events:none;
      z-index:9999;
    }
    #transition.hide{
      opacity:0;
      transition: opacity 260ms linear;
    }

    #transitionImg, #transitionVideo{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }

    #ui-mask{
      position:absolute;
      left:0;
      right:0;
      bottom:0;
      height:64px;
      background:#000;
      z-index:10000;
      pointer-events:none;
      display:none;
    }
    body.mask #ui-mask{ display:block; }

    /* Simple loading overlay - shows briefly on fresh source load */
    #loadingOverlay{
      position:absolute;
      inset:0;
      z-index:99999;
      pointer-events:none;
      background: #000;
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:1;
      transition: opacity 400ms ease-out;
    }
    #loadingOverlay.hide{ opacity:0; pointer-events:none; }

    #loadingOverlay .content{
      text-align:center;
      color:#fff;
      font: 600 24px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    #loadingOverlay .spinner{
      width:48px;
      height:48px;
      border-radius:50%;
      border:4px solid rgba(255,255,255,0.2);
      border-top-color: #fff;
      margin: 0 auto 20px auto;
      animation: spin 0.8s linear infinite;
    }

    #loadingOverlay .text{
      opacity:0.9;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    #voteHud{
      position:absolute;
      left:50%;
      top:24px;
      z-index:11000;
      display:flex;
      gap:14px;
      align-items:center;
      padding:14px 18px;
      border-radius:14px;
      background: rgba(0,0,0,0.75);
      border: 2px solid rgba(255,255,255,0.25);
      color:#fff;
      font: 18px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      user-select:none;
      pointer-events:none;
      backdrop-filter: blur(8px);
      opacity:0;
      transform: translateX(-50%) translateY(-6px);
      transition: opacity 180ms linear, transform 180ms linear;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    #voteHud.show{
      opacity:1;
      transform: translateX(-50%) translateY(0);
    }
    #voteHud .seq{
      font-weight:800;
      font-size:20px;
      letter-spacing:.3px;
      color:#fff;
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    #voteHud .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 14px;
      border-radius:999px;
      font-weight:700;
      font-size:18px;
    }
    #voteHud .pill.up{
      background: rgba(34,197,94,0.2);
      border: 2px solid rgba(34,197,94,0.6);
      color: #4ade80;
    }
    #voteHud .pill.down{
      background: rgba(239,68,68,0.2);
      border: 2px solid rgba(239,68,68,0.6);
      color: #f87171;
    }
    #voteHud .hints{
      display:flex;
      flex-direction:column;
      gap:4px;
      font-size:14px;
      font-weight:700;
    }
    #voteHud .hint-like{
      color: #4ade80;
    }
    #voteHud .hint-dislike{
      color: #f87171;
    }

    /* Debug overlay - add ?debug=1 to URL to show */
    #debugOverlay{
      position:absolute;
      right:10px;
      bottom:10px;
      z-index:999999;
      background: rgba(0,0,0,0.95);
      color:#0f0;
      font: 12px/1.4 monospace;
      padding:10px 12px;
      border-radius:6px;
      border: 2px solid #0f0;
      max-width:450px;
      max-height:250px;
      overflow:hidden;
      display:none;
      pointer-events:none;
    }
    #debugOverlay.show{ display:block; }
    #debugOverlay .line{ margin:2px 0; }
    #debugOverlay .ok{ color:#4ade80; }
    #debugOverlay .err{ color:#f87171; }
    #debugOverlay .warn{ color:#fbbf24; }
  </style>
</head>

<body>
  <div class="stage">
    <div class="viewport" id="viewport">
      <div class="frameWrap">
        <iframe id="frameA" allow="autoplay; fullscreen" allowfullscreen></iframe>
        <iframe id="frameB" allow="autoplay; fullscreen" allowfullscreen></iframe>
      </div>
    </div>

    <div id="transition" class="hide" aria-hidden="true">
      <!-- Use video instead of GIF for reliable loading in OBS browser source -->
      <!-- If you have transition.mp4/webm, it will use that; falls back to GIF -->
      <video id="transitionVideo" muted playsinline loop preload="auto" style="display:none;">
        <source src="/flop/transition.webm" type="video/webm">
        <source src="/flop/transition.mp4" type="video/mp4">
      </video>
      <img id="transitionImg" src="/flop/transition.gif" alt="">
    </div>

    <div id="ui-mask"></div>

    <div id="voteHud" aria-hidden="true">
      <span class="seq" id="voteSeq">Clip</span>
      <span class="pill up" id="voteUp">üëç 0</span>
      <span class="pill down" id="voteDown">üëé 0</span>
      <div class="hints">
        <span class="hint-like" id="hintLike">!like #</span>
        <span class="hint-dislike" id="hintDislike">!dislike #</span>
      </div>
    </div>

    <div id="loadingOverlay" aria-hidden="true">
      <div class="content">
        <div class="spinner"></div>
        <div class="text">Loading Clips...</div>
      </div>
    </div>

    <div id="debugOverlay" aria-hidden="true"></div>
  </div>

<script>
(() => {
  const qs = new URLSearchParams(location.search);

  const login  = (qs.get("login") || "floppyjimmie").toLowerCase();
  const parent = qs.get("parent") || location.hostname;
  const days   = parseInt(qs.get("days") || "180", 10);
  const pool   = parseInt(qs.get("pool") || "400", 10);

  // Detect if this is a fresh page load vs returning to existing source
  // sessionStorage clears when browser source is refreshed/updated
  // We only skip boot if GIF was loaded THIS session (not from previous)
  const SESSION_KEY = `session_${login}`;
  const GIF_LOADED_KEY = `gif_loaded_${login}`;
  let gifLoadedThisSession = false;
  try {
    const currentSession = sessionStorage.getItem(SESSION_KEY);
    const gifLoaded = sessionStorage.getItem(GIF_LOADED_KEY);
    // Only consider cached if we have BOTH a session marker AND gif loaded marker
    // This means we've already successfully loaded the GIF in this exact browser session
    gifLoadedThisSession = !!(currentSession && gifLoaded);
    console.log("[INIT] Session exists:", !!currentSession, "GIF loaded:", !!gifLoaded, "Skip boot:", gifLoadedThisSession);

    // Always set session marker on load
    if (!currentSession) {
      sessionStorage.setItem(SESSION_KEY, String(Date.now()));
    }
  } catch {}

  const fastMode   = qs.get("fast") === "1";
  const fakeMobile = qs.get("mobile") === "1";

  if (qs.get("overscan") === "1") document.body.classList.add("overscan");
  if (qs.get("mask") === "1") document.body.classList.add("mask");
  if (fakeMobile) document.body.classList.add("fakeMobile");

  // Railway API base URL
  const API_BASE = "https://clipsystem-production.up.railway.app";
  const apiUrl = `${API_BASE}/twitch_reel_api.php?login=${encodeURIComponent(login)}&days=${days}&pool=${pool}`;

  const RECENT_BLOCK = Math.max(10, Math.floor(pool * 0.20));
  const storageKey = `away_reel_state_${login}`;

  const viewport      = document.getElementById("viewport");
  const frameA        = document.getElementById("frameA");
  const frameB        = document.getElementById("frameB");
  const transition    = document.getElementById("transition");
  const transitionImg = document.getElementById("transitionImg");
  const transitionVideo = document.getElementById("transitionVideo");

  // Determine if we should use video or GIF for transitions
  // Video is preferred as it loads much more reliably in OBS browser source
  let useVideoTransition = false;

  const loadingOverlay = document.getElementById("loadingOverlay");

  // Show loading overlay on first load only (not when already loaded this session)
  // Refreshing/updating the browser source clears sessionStorage, so it shows again
  const showLoadingOnStart = !gifLoadedThisSession;

  // Debug overlay - add ?debug=1 to URL to show
  const debugEnabled = qs.get("debug") === "1";
  const debugOverlay = document.getElementById("debugOverlay");
  const debugLines = [];
  const MAX_DEBUG_LINES = 12;

  function debugLog(msg, type = "info") {
    if (!debugEnabled) return;
    const time = new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" });
    debugLines.push({ time, msg, type });
    if (debugLines.length > MAX_DEBUG_LINES) debugLines.shift();
    renderDebug();
  }

  function renderDebug() {
    if (!debugEnabled || !debugOverlay) return;
    debugOverlay.classList.add("show");
    debugOverlay.innerHTML = debugLines.map(l => {
      const cls = l.type === "ok" ? "ok" : l.type === "err" ? "err" : l.type === "warn" ? "warn" : "";
      return `<div class="line ${cls}">${l.time} ${l.msg}</div>`;
    }).join("");
  }

  // ===== Vote HUD polling =====
  const voteHud  = document.getElementById("voteHud");
  const voteSeq  = document.getElementById("voteSeq");
  const voteUp   = document.getElementById("voteUp");
  const voteDown = document.getElementById("voteDown");
  const hintLike = document.getElementById("hintLike");
  const hintDislike = document.getElementById("hintDislike");

  const hudEnabled = qs.get("hud") !== "0";
  const hudPollMs  = Math.max(350, Math.min(2500, parseInt(qs.get("hudpoll") || "900", 10)));

  // Client-side seq tracking - updates HUD immediately without waiting for server
  let currentHudSeq = 0;
  let currentHudClipId = null;

  // Update HUD seq immediately from local clip data (no server needed)
  function updateHudSeqLocal(clip) {
    if (!hudEnabled || !clip) return;

    // Get seq from clip object (set by index) or fallback to array position
    let seq = clip.seq;
    if (!seq && clips.length) {
      // Find clip position in array as fallback
      const idx = clips.findIndex(c => c.id === clip.id);
      if (idx >= 0) seq = idx + 1;
    }

    if (seq && seq > 0) {
      currentHudSeq = seq;
      currentHudClipId = clip.id;
      voteSeq.textContent = `Clip #${seq}`;
      hintLike.textContent = `!like ${seq}`;
      hintDislike.textContent = `!dislike ${seq}`;
      voteHud.classList.add("show");
      debugLog("HUD seq=" + seq + " (local)", "ok");
    }
  }

  // Render votes from server (seq comes from local tracking now)
  function renderHudVotes(data){
    if (!hudEnabled) return;

    // Only update vote counts, not seq (seq is tracked locally)
    voteUp.textContent = `üëç ${Number(data?.up || 0)}`;
    voteDown.textContent = `üëé ${Number(data?.down || 0)}`;
    voteHud.classList.add("show");
  }

  async function pollHudOnce(){
    if (!hudEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/vote_status.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      // Only use server seq if we don't have local tracking yet
      if (data && typeof data.seq === "number" && currentHudSeq === 0) {
        currentHudSeq = data.seq;
        voteSeq.textContent = `Clip #${data.seq}`;
        hintLike.textContent = `!like ${data.seq}`;
        hintDislike.textContent = `!dislike ${data.seq}`;
      }
      renderHudVotes(data);
    } catch {}
  }

  if (hudEnabled) {
    pollHudOnce();
    setInterval(pollHudOnce, hudPollMs);
  }

  // ===== Simple loading overlay (replaces old matrix rain) =====
  // Show for 5-10 seconds on fresh source load, then fade out
  const LOADING_OVERLAY_MIN_MS     = 5000;   // Minimum 5 seconds display
  const LOADING_EXTRA_SETTLE_MS    = 1000;   // Extra settle after iframe loads
  const MEDIA_PRELOAD_MIN_MS       = 2000;   // Minimum time for video/GIF preload
  let loadingShownAt = 0;
  let mediaPreloadStartedAt = 0;

  // Show loading overlay on fresh source load
  if (showLoadingOnStart) {
    loadingShownAt = Date.now();
    loadingOverlay.classList.remove("hide");
    debugLog("LOADING: showing overlay");
  } else {
    loadingOverlay.classList.add("hide");
    debugLog("LOADING: skipped (session cached)");
  }

  function showLoadingOverlay(){
    if (!showLoadingOnStart) return;
    loadingOverlay.classList.remove("hide");
    if (loadingShownAt === 0) loadingShownAt = Date.now();
  }

  function hideLoadingOverlay(){
    loadingOverlay.classList.add("hide");
    debugLog("LOADING: hidden");
  }

  // ===== Timing knobs =====
  const TRANSITION_PREROLL_MS      = 120;
  const TRANSITION_MIN_MS          = 380;
  const TRANSITION_AFTER_REVEAL_MS = 120;
  const IFRAME_LOAD_FAILSAFE_MS    = 8000;

  const IFRAME_SETTLE_PAD_MS       = 350;
  const LOAD_SLOW_THRESHOLD_MS     = 1200;
  const LOAD_SLOW_EXTRA_MS         = 500;

  let transitionShownAt = 0;

  let liveFrame = frameA;
  let backFrame = frameB;

  let clips = [];
  let advanceTimer = null;
  let transitionTimer = null;
  let prepareTimer = null;

  let nextClip = null;
  let nextToken = 0;

  let firstTransitionShown = false;

  // ===== RESUME / BLACK-SCREEN RECOVERY =====
  let hasStartedPlayback = false;
  let isSwitching = false;

  function anyLiveVisible(){
    return frameA.classList.contains("live") || frameB.classList.contains("live");
  }

  function recoverFromBlack(){
    if (!hasStartedPlayback) return;
    if (isSwitching) return;
    if (!transition.classList.contains("hide")) return;
    if (!anyLiveVisible() && clips.length) {
      showTransition();
    }
  }

  setInterval(recoverFromBlack, 700);

  function applyFakeMobileScale() {
    if (!fakeMobile) return;
    const baseW = 390, baseH = 844;
    const s = Math.min(window.innerWidth / baseW, window.innerHeight / baseH);
    viewport.style.setProperty("--embed-scale", String(s));
  }
  window.addEventListener("resize", applyFakeMobileScale);
  applyFakeMobileScale();

  function loadState() {
    try { return JSON.parse(localStorage.getItem(storageKey) || "{}"); }
    catch { return {}; }
  }
  function saveState(state) { localStorage.setItem(storageKey, JSON.stringify(state)); }
  function nowMs(){ return Date.now(); }

  const TRANSITION_GIF_BASE = "/flop/transition.gif";

  // ===== Transition gif restart that actually replays in OBS =====
  function restartGifHard(url){
    // Use blob URL if available (already in memory, no network request)
    // Fall back to regular URL otherwise
    const srcToUse = transitionGifBlobUrl || url;

    transitionImg.src = "";
    requestAnimationFrame(() => {
      transitionImg.src = srcToUse;
    });
  }

  // Preload the transition media (video preferred, GIF fallback)
  let transitionMediaReady = false;
  let transitionGifBlobUrl = null;

  // Try to load video first (much more reliable in OBS), fall back to GIF
  async function preloadTransitionMedia(){
    mediaPreloadStartedAt = Date.now();

    const minWait = gifLoadedThisSession ? 500 : MEDIA_PRELOAD_MIN_MS;
    console.log("[TRANSITION] Starting preload, session loaded:", gifLoadedThisSession, "minWait:", minWait);

    return new Promise((resolve) => {
      let resolved = false;
      const finish = (success, isVideo = false) => {
        if (resolved) return;
        resolved = true;

        if (success) {
          transitionMediaReady = true;
          useVideoTransition = isVideo;
          try { sessionStorage.setItem(GIF_LOADED_KEY, "1"); } catch {}
        }

        console.log("[TRANSITION] Preload complete. Success:", success, "Using video:", isVideo);

        // Show/hide appropriate element
        if (isVideo) {
          transitionVideo.style.display = "block";
          transitionImg.style.display = "none";
        } else {
          transitionVideo.style.display = "none";
          transitionImg.style.display = "block";
        }

        // Ensure minimum preload time has passed
        const elapsed = Date.now() - mediaPreloadStartedAt;
        const remaining = Math.max(0, minWait - elapsed);
        if (remaining > 0) {
          console.log("[TRANSITION] Waiting additional", remaining, "ms for buffer time");
          setTimeout(() => resolve(success), remaining);
        } else {
          resolve(success);
        }
      };

      // FIRST: Try video (much more reliable in OBS browser source)
      if (transitionVideo) {
        console.log("[TRANSITION] Trying video sources first...");

        let videoTimeout = setTimeout(() => {
          console.log("[TRANSITION] Video load timeout, falling back to GIF");
          tryGifFallback();
        }, 5000);

        // Check if video can play
        transitionVideo.oncanplaythrough = () => {
          clearTimeout(videoTimeout);
          console.log("[TRANSITION] Video ready to play through!");
          transitionVideo.oncanplaythrough = null;
          transitionVideo.onerror = null;
          finish(true, true);
        };

        transitionVideo.onerror = (e) => {
          clearTimeout(videoTimeout);
          console.log("[TRANSITION] Video error, falling back to GIF:", e);
          transitionVideo.oncanplaythrough = null;
          transitionVideo.onerror = null;
          tryGifFallback();
        };

        // Trigger video load
        transitionVideo.load();

        // Also check if already ready (cached)
        if (transitionVideo.readyState >= 4) {
          clearTimeout(videoTimeout);
          transitionVideo.oncanplaythrough = null;
          transitionVideo.onerror = null;
          console.log("[TRANSITION] Video already cached and ready!");
          finish(true, true);
          return;
        }
      } else {
        tryGifFallback();
      }

      function tryGifFallback() {
        console.log("[TRANSITION] Loading GIF fallback...");

        // Fetch GIF as blob for reliable loading
        fetch(TRANSITION_GIF_BASE, { cache: "force-cache" })
          .then(r => {
            if (!r.ok) throw new Error("HTTP " + r.status);
            return r.blob();
          })
          .then(blob => {
            console.log("[TRANSITION] GIF downloaded, size:", blob.size, "bytes");

            if (blob.size < 1000) throw new Error("Blob too small");

            const blobUrl = URL.createObjectURL(blob);
            transitionGifBlobUrl = blobUrl;

            // Load into image element
            transitionImg.onload = () => {
              console.log("[TRANSITION] GIF loaded:", transitionImg.naturalWidth, "x", transitionImg.naturalHeight);

              // Force decode by drawing to canvas
              try {
                const canvas = document.createElement('canvas');
                canvas.width = transitionImg.naturalWidth;
                canvas.height = transitionImg.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(transitionImg, 0, 0);
                console.log("[TRANSITION] GIF decoded via canvas");
              } catch (e) {}

              finish(true, false);
            };

            transitionImg.onerror = () => {
              console.warn("[TRANSITION] GIF blob load failed, trying direct URL");
              transitionImg.src = TRANSITION_GIF_BASE;
              setTimeout(() => finish(transitionImg.complete, false), 1000);
            };

            transitionImg.src = blobUrl;
          })
          .catch(err => {
            console.warn("[TRANSITION] GIF fetch failed:", err);
            transitionImg.src = TRANSITION_GIF_BASE;
            transitionImg.onload = () => finish(transitionImg.complete, false);
            transitionImg.onerror = () => finish(false, false);
          });
      }

      // Final timeout fallback
      const timeout = gifLoadedThisSession ? 6000 : 12000;
      setTimeout(() => {
        if (!resolved) {
          console.warn("[TRANSITION] Preload timeout after", timeout, "ms");
          // Use whatever we have
          const videoReady = transitionVideo && transitionVideo.readyState >= 2;
          const gifReady = transitionImg.complete && transitionImg.naturalWidth > 0;
          finish(videoReady || gifReady, videoReady);
        }
      }, timeout);
    });
  }

  async function preloadTransitionGifSoft(timeoutMs){
    const t0 = Date.now();
    try { fetch(TRANSITION_GIF_BASE, { cache: "force-cache" }); } catch {}
    while (Date.now() - t0 < timeoutMs) {
      if (transitionImg.complete) break;
      await new Promise(r => setTimeout(r, 30));
    }
  }

  async function warmupTwitchEmbedSoft(timeoutMs){
    const warmUrl = `https://clips.twitch.tv/embed?clip=InvalidClip&parent=${encodeURIComponent(parent)}&autoplay=false&muted=true`;
    return await Promise.race([
      (async () => {
        await new Promise(resolve => {
          const f = document.createElement("iframe");
          f.style.position = "absolute";
          f.style.width = "1px";
          f.style.height = "1px";
          f.style.left = "-9999px";
          f.style.top = "-9999px";
          f.setAttribute("aria-hidden", "true");
          f.setAttribute("tabindex", "-1");
          f.allow = "autoplay; fullscreen";
          f.src = warmUrl;

          let done = false;
          const finish = () => {
            if (done) return;
            done = true;
            try { f.onload = null; } catch {}
            setTimeout(() => { try { f.remove(); } catch {} }, 250);
            resolve();
          };

          f.onload = finish;
          setTimeout(finish, 900);
          document.body.appendChild(f);
        });
      })(),
      new Promise(r => setTimeout(r, timeoutMs))
    ]);
  }

  function showTransition(){
    transitionShownAt = Date.now();

    if (useVideoTransition && transitionVideo) {
      // Video mode - restart and play the video
      transitionVideo.currentTime = 0;
      transitionVideo.play().catch(e => console.warn("[TRANSITION] Video play failed:", e));
    } else {
      // GIF mode - restart the GIF animation
      restartGifHard(TRANSITION_GIF_BASE);
    }

    transition.classList.remove("hide");
  }

  function hideTransitionAfterHold() {
    const elapsed = Date.now() - transitionShownAt;
    const waitToMin = Math.max(0, TRANSITION_MIN_MS - elapsed);
    setTimeout(() => transition.classList.add("hide"), waitToMin);
  }

  function clearTimers() {
    if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
    if (transitionTimer) { clearTimeout(transitionTimer); transitionTimer = null; }
    if (prepareTimer) { clearTimeout(prepareTimer); prepareTimer = null; }
  }

  function clipSrc(id, autoplay) {
    const ap = autoplay ? "true" : "false";
    return `https://clips.twitch.tv/embed?clip=${encodeURIComponent(id)}&parent=${encodeURIComponent(parent)}&autoplay=${ap}&muted=false`;
  }

  // Track what we've set as now playing to avoid duplicate calls
  let lastSetNowPlayingId = null;
  let nowPlayingCallCount = 0;  // Debug counter

  // Rate limiting for now_playing_set to avoid 403 from Porkbun
  const NP_MIN_INTERVAL_MS = 5000;  // Minimum 5 seconds between API calls
  let lastNpCallTime = 0;
  let pendingNpClip = null;
  let npQueueTimer = null;

  async function setNowPlaying(c, forceSet = false) {
    const callNum = ++nowPlayingCallCount;
    try {
      const url = (c && c.url) ? String(c.url) : "";
      const clipId = (c && c.id) ? String(c.id) : "";
      if (!clipId) {
        debugLog("NP#" + callNum + " NO CLIP_ID", "err");
        return false;
      }

      // Skip if we already set this clip (prevents duplicate calls) - unless forced
      if (!forceSet && clipId === lastSetNowPlayingId) {
        debugLog("NP#" + callNum + " skip (same)", "warn");
        return true;
      }

      debugLog("NP#" + callNum + " GET " + clipId.substring(0, 20));
      // Use GET instead of POST - some hosts rate-limit POST more aggressively
      const params = new URLSearchParams({
        login: login,
        url: url,
        clip_id: clipId
      });
      const res = await fetch(`${API_BASE}/now_playing_set.php?` + params.toString(), {
        method: "GET",
        cache: "no-store"
      });
      const text = await res.text();

      if (res.ok && text.trim() === "ok") {
        lastSetNowPlayingId = clipId;
        lastNpCallTime = Date.now();  // Track successful call time
        debugLog("NP#" + callNum + " OK seq updated", "ok");
        return true;
      } else {
        debugLog("NP#" + callNum + " FAIL " + res.status + " " + text.substring(0, 20), "err");
        return false;
      }
    } catch (err) {
      debugLog("NP#" + callNum + " ERR " + String(err).substring(0, 30), "err");
      return false;
    }
  }

  // Rate-limited version that queues calls to avoid 403 rate limiting
  // Only ONE call will be made per NP_MIN_INTERVAL_MS, using the most recent clip
  function setNowPlayingWithRetry(c) {
    const clipId = (c && c.id) ? String(c.id) : "";
    if (!clipId) {
      debugLog("NP: no clip_id!", "err");
      return;
    }

    const now = Date.now();
    const timeSinceLastCall = now - lastNpCallTime;

    // If enough time has passed, make the call immediately
    if (timeSinceLastCall >= NP_MIN_INTERVAL_MS) {
      debugLog("NP: immediate " + clipId.substring(0, 15));
      lastSetNowPlayingId = null;  // Force the call to go through
      setNowPlaying(c, true);
      return;
    }

    // Otherwise, queue it for later (replacing any previous pending)
    pendingNpClip = c;
    const waitMs = NP_MIN_INTERVAL_MS - timeSinceLastCall + 100;  // Add 100ms buffer
    debugLog("NP: queued " + clipId.substring(0, 15) + " wait=" + waitMs + "ms", "warn");

    // Only set timer if not already waiting
    if (!npQueueTimer) {
      npQueueTimer = setTimeout(() => {
        npQueueTimer = null;
        if (pendingNpClip) {
          const queued = pendingNpClip;
          pendingNpClip = null;
          debugLog("NP: dequeue " + (queued.id || "?").substring(0, 15));
          lastSetNowPlayingId = null;
          setNowPlaying(queued, true);
        }
      }, waitMs);
    }
  }

  function computeRevealDelayMs(loadMs) {
    let d = 950;
    if (loadMs > 900)  d += 300;
    if (loadMs > 1500) d += 450;
    return Math.min(1800, Math.max(850, d));
  }

  // Check if the transition media (video or GIF) is properly loaded
  function isTransitionMediaReady() {
    if (useVideoTransition && transitionVideo) {
      return transitionVideo.readyState >= 2;
    }
    return transitionMediaReady || (transitionImg.complete && transitionImg.naturalWidth > 0);
  }

  // Wait for transition media to be ready
  async function waitForTransitionMedia(maxMs = 3000) {
    const start = Date.now();
    // First check if already fully loaded
    if (transitionMediaReady) {
      console.log("[TRANSITION] Already ready");
      return true;
    }
    // Otherwise wait for it
    while (Date.now() - start < maxMs) {
      if (transitionMediaReady) {
        console.log("[TRANSITION] Ready after", Date.now() - start, "ms");
        return true;
      }
      if (useVideoTransition && transitionVideo && transitionVideo.readyState >= 2) {
        return true;
      }
      if (!useVideoTransition && transitionImg.complete && transitionImg.naturalWidth > 0) {
        await new Promise(r => setTimeout(r, 200));
        return true;
      }
      await new Promise(r => setTimeout(r, 50));
    }
    console.warn("[TRANSITION] Wait timeout after", maxMs, "ms, proceeding anyway");
    return isTransitionMediaReady();
  }

  // Extra time to let clip video buffer after iframe loads (for first clip)
  const FIRST_CLIP_BUFFER_MS = 1500;  // Give first clip extra time to buffer video

  function revealIframeThenFadeOut(frameToReveal, loadStartedAt) {
    const loadMs = loadStartedAt ? (Date.now() - loadStartedAt) : 0;
    const revealDelay = computeRevealDelayMs(loadMs);

    let extra = IFRAME_SETTLE_PAD_MS;
    if (loadMs > LOAD_SLOW_THRESHOLD_MS) extra += LOAD_SLOW_EXTRA_MS;

    setTimeout(async () => {
      // Hide loading overlay when first clip actually reveals
      if (!firstTransitionShown) {
        // Ensure loading overlay was shown for minimum time (5-10 seconds)
        const loadingElapsed = Date.now() - loadingShownAt;
        const loadingRemaining = Math.max(0, LOADING_OVERLAY_MIN_MS - loadingElapsed);

        // Wait for transition media (video or GIF) to be ready
        await waitForTransitionMedia(2000);

        // If we need more time for loading minimum, wait
        if (loadingRemaining > 0) {
          console.log("[LOADING] Waiting additional", loadingRemaining, "ms for minimum display");
          await new Promise(r => setTimeout(r, loadingRemaining));
        }

        // Extra settle time to ensure clip video is buffered
        await new Promise(r => setTimeout(r, LOADING_EXTRA_SETTLE_MS));

        console.log("[LOADING] Requirements met, hiding overlay");
        hideLoadingOverlay();
        firstTransitionShown = true;

        // For first clip, add extra buffer time before fading out transition
        await new Promise(r => setTimeout(r, FIRST_CLIP_BUFFER_MS));
      }

      frameToReveal.classList.add("live");
      setTimeout(() => hideTransitionAfterHold(), TRANSITION_AFTER_REVEAL_MS + extra);
    }, revealDelay);
  }

  const POP_WEIGHT = 0.55;
  const POP_CAP = 1.8;
  function log10Safe(x){ return Math.log10 ? Math.log10(x) : (Math.log(x) / Math.LN10); }

  function pickNextClip() {
    const state = loadState();
    state.recent = Array.isArray(state.recent) ? state.recent : [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};
    state.lastGameRecent = Array.isArray(state.lastGameRecent) ? state.lastGameRecent : [];

    const recentSet = new Set(state.recent.slice(-RECENT_BLOCK));
    const recentGames = state.lastGameRecent.slice(-6);

    const candidates = clips.filter(c => !recentSet.has(c.id));
    const usable = candidates.length ? candidates : clips.slice();

    const scored = usable.map(c => {
      const plays = state.playCounts[c.id] || 0;
      const lastAt = state.lastPlayedAt[c.id] || 0;
      const minutesAgo = (nowMs() - lastAt) / 60000;

      let score = 1;
      score += Math.min(5, minutesAgo / 15);
      score += Math.max(0, 3 - plays);
      if (c.game_id && recentGames.includes(c.game_id)) score -= 2;

      const views = Number(c.view_count || 0);
      const pop = log10Safe(views + 1);
      score += Math.min(POP_CAP, pop * POP_WEIGHT);

      return { c, score };
    }).filter(x => x.score > 0.1);

    scored.sort((a,b) => b.score - a.score);
    const top = scored.slice(0, Math.min(25, scored.length));

    const total = top.reduce((s, x) => s + x.score, 0);
    let r = Math.random() * total;
    for (const x of top) { r -= x.score; if (r <= 0) return x.c; }
    return top[0]?.c || clips[0];
  }

  function markPlayed(c) {
    const state = loadState();
    state.recent = Array.isArray(state.recent) ? state.recent : [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};
    state.lastGameRecent = Array.isArray(state.lastGameRecent) ? state.lastGameRecent : [];

    state.recent.push(c.id);
    if (state.recent.length > 2000) state.recent = state.recent.slice(-800);

    state.playCounts[c.id] = (state.playCounts[c.id] || 0) + 1;
    state.lastPlayedAt[c.id] = nowMs();

    if (c.game_id) {
      state.lastGameRecent.push(c.game_id);
      if (state.lastGameRecent.length > 50) state.lastGameRecent = state.lastGameRecent.slice(-20);
    }
    saveState(state);
  }

  function scheduleNext(durationSec) {
    clearTimers();
    const d = Math.max(6, Number(durationSec) || 20);
    console.log("[SCHEDULE] Scheduling next clip in", d, "seconds (duration was:", durationSec, ")");

    const preAt = Math.max(0, (d * 1000) - TRANSITION_PREROLL_MS);

    prepareTimer = setTimeout(() => {
      console.log("[SCHEDULE] Prepare timer fired");
    }, Math.max(0, preAt - 450));

    transitionTimer = setTimeout(() => {
      console.log("[SCHEDULE] Transition timer fired, showing transition");
      showTransition();
    }, preAt);

    if (fastMode) {
      const preloadAtMs = Math.min(
        Math.max(1500, Math.floor(d * 0.85) * 1000),
        Math.max(1500, (d - 3) * 1000)
      );
      setTimeout(() => {
        console.log("[SCHEDULE] Preload timer fired");
        preloadNext();
      }, preloadAtMs);
    }

    advanceTimer = setTimeout(() => {
      console.log("[SCHEDULE] Advance timer fired, switching to next clip");
      if (fastMode) switchFast();
      else switchSmoothBuffered();
    }, (d + 1) * 1000);
  }

  function bindOnloadWithFailsafe(targetFrame, onReady) {
    let done = false;
    try { targetFrame.onload = null; } catch {}

    const t = setTimeout(() => {
      if (done) return;
      done = true;
      try { targetFrame.onload = null; } catch {}
      onReady(true);
    }, IFRAME_LOAD_FAILSAFE_MS);

    targetFrame.onload = () => {
      if (done) return;
      done = true;
      clearTimeout(t);
      onReady(false);
    };
  }

  // Track current clip for verification
  let currentClipId = null;

  let switchCount = 0;  // Debug counter

  function switchToClip(c) {
    const switchNum = ++switchCount;
    if (!c) {
      debugLog("SW#" + switchNum + " null clip!", "err");
      return;
    }
    debugLog("SW#" + switchNum + " -> " + (c.id || "?").substring(0, 15) + " dur=" + c.duration);

    // Clear any pending timers when starting a new switch
    clearTimers();
    isSwitching = true;

    // Store clip reference to ensure we use the right one
    const clipToPlay = c;
    currentClipId = c.id;

    if (transition.classList.contains("hide")) {
      console.log("[SWITCH] Showing transition");
      showTransition();
    }
    const token = ++nextToken;
    const switchStartedAt = Date.now();

    backFrame.classList.remove("live");

    const loadStartedAt = Date.now();
    bindOnloadWithFailsafe(backFrame, (wasFailsafe) => {
      // Check if we were superseded by another switch
      if (token !== nextToken) {
        debugLog("SW#" + switchNum + " token mismatch, skipped", "warn");
        // Don't set isSwitching=false here, the newer switch will handle it
        return;
      }
      debugLog("SW#" + switchNum + " loaded" + (wasFailsafe ? " (failsafe)" : ""), "ok");

      liveFrame.classList.remove("live");
      revealIframeThenFadeOut(backFrame, loadStartedAt);

      const tmp = liveFrame;
      liveFrame = backFrame;
      backFrame = tmp;

      try { backFrame.onload = null; } catch {}
      setTimeout(() => { try { backFrame.src = "about:blank"; } catch {} }, 300);

      markPlayed(clipToPlay);

      // Update HUD seq immediately from local data (no server round-trip needed)
      updateHudSeqLocal(clipToPlay);

      // Also try to update server (for !pb command) - may fail due to rate limits
      debugLog("SW#" + switchNum + " calling setNowPlaying");
      setNowPlayingWithRetry(clipToPlay);

      // Ensure we have a valid duration
      const dur = (clipToPlay.duration && clipToPlay.duration > 0) ? clipToPlay.duration : 30;
      scheduleNext(dur);
      debugLog("SW#" + switchNum + " next in " + dur + "s");

      isSwitching = false;
      hasStartedPlayback = true;

      // Check for pending forced clip after switch completes
      if (pendingForced && pendingForced.clip) {
        debugLog("SW#" + switchNum + " has pending forced", "warn");
        const forced = pendingForced.clip;
        pendingForced = null;
        setTimeout(() => switchToClip(forced), 100);
      }
    });

    backFrame.src = clipSrc(clipToPlay.id, true);
    console.log("[SWITCH] Iframe src set, token:", token);

    // Safety: reset isSwitching after a reasonable timeout if callback never fires
    setTimeout(() => {
      if (token === nextToken && isSwitching) {
        console.warn("[SWITCH] Safety timeout - callback never fired after", Date.now() - switchStartedAt, "ms");

        // Even on timeout, try to set now playing so the HUD stays in sync
        console.log("[SWITCH] Safety: setting now playing for:", clipToPlay.id);
        setNowPlayingWithRetry(clipToPlay);

        isSwitching = false;
        // Force advancement to recover
        if (clips.length) {
          console.log("[SWITCH] Attempting recovery by switching to next clip");
          switchToClip(pickNextClip());
        }
      }
    }, 15000); // 15 second safety timeout
  }

  function switchSmoothBuffered() {
    console.log("[SMOOTH] switchSmoothBuffered called, clips.length:", clips.length, "isSwitching:", isSwitching);
    if (!clips.length) {
      console.warn("[SMOOTH] No clips available!");
      return;
    }
    const next = pickNextClip();
    console.log("[SMOOTH] Picked next clip:", next?.id, next?.title);
    switchToClip(next);
  }

  function preloadNext() {
    if (!clips.length) return;
    if (nextClip) return;
    // Don't preload if we're currently switching - it will mess up the token
    if (isSwitching) return;

    nextClip = pickNextClip();
    if (!nextClip) return;

    // Clear any existing onload handler before preloading
    // This prevents the preload from triggering the switch callback
    try { backFrame.onload = null; } catch {}

    // Don't increment nextToken here - only switchToClip should do that
    // Just quietly load the clip in the background
    backFrame.src = clipSrc(nextClip.id, false);
  }

  function switchFast() {
    if (!clips.length) return;

    if (!nextClip) preloadNext();
    const c = nextClip || pickNextClip();
    if (!c) return;

    switchToClip(c);
    nextClip = null;
    setTimeout(preloadNext, 900);
  }

  // ===== pclip support, switch by clip_id first =====
  const pclipEnabled = qs.get("pclip") !== "0";
  const pclipPollMs = Math.max(350, Math.min(2500, parseInt(qs.get("pclippoll") || "700", 10)));

  let lastPclipNonce = null;
  let pendingForced = null;

  function clipBySeq(seq){
    const n = parseInt(seq, 10);
    if (!Number.isFinite(n)) return null;
    if (n < 1 || n > clips.length) return null;
    return clips[n - 1];
  }

  function clipById(id){
    const s = (id == null) ? "" : String(id).trim();
    if (!s) return null;
    return clips.find(c => String(c.id) === s) || null;
  }

  async function pollPclipOnce(){
    if (!pclipEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/force_play_get.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (!data || Object.keys(data).length === 0) return;

      const nonce = (data.nonce != null) ? String(data.nonce) : null;
      if (!nonce || nonce === lastPclipNonce) return;
      lastPclipNonce = nonce;
      console.log("[PCLIP] Force play command received:", data);

      // Try to find in current pool first
      let c = clipById(data.clip_id);

      // If not in pool, use full clip data from server response
      if (!c && data.clip) {
        console.log("[PCLIP] Clip not in current pool, using server data");
        c = data.clip;
        // Ensure the clip has a duration, default to 30 seconds if missing
        if (!c.duration || c.duration <= 0) {
          console.warn("[PCLIP] Clip missing duration, defaulting to 30s");
          c.duration = 30;
        }
      }

      if (!c) {
        console.warn("[PCLIP] Could not find clip for:", data.clip_id, data.seq);
        return;
      }

      // If currently switching, queue this clip for later
      if (isSwitching) {
        console.log("[PCLIP] Switch in progress, queuing forced clip for later");
        pendingForced = { clip: c };
        return;
      }

      // Force the switch immediately
      console.log("[PCLIP] Switching to forced clip:", c.id, "duration:", c.duration, "isSwitching:", isSwitching);
      switchToClip(c);

      // Clear the force_play file so it doesn't replay on refresh
      try {
        fetch(`${API_BASE}/force_play_clear.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      } catch {}
    } catch (err) {
      console.error("[PCLIP] Poll error:", err);
    }
  }

  function startPclipPolling(){
    if (!pclipEnabled) return;
    pollPclipOnce();
    setInterval(pollPclipOnce, pclipPollMs);
  }

  async function init() {
    console.log("[INIT] Starting init...");
    showLoadingOverlay();       // show immediately on fresh load
    console.log("[INIT] Loading overlay shown");

    // Start preloading the transition media (video preferred, GIF fallback)
    // This MUST complete before we load any clips
    console.log("[INIT] Starting transition preload (will wait at least", MEDIA_PRELOAD_MIN_MS, "ms)...");
    const mediaPreloadPromise = preloadTransitionMedia();

    // Also do soft warmups in parallel (but don't start clip loading yet)
    preloadTransitionGifSoft(800);
    warmupTwitchEmbedSoft(900);

    // CRITICAL: Wait for media to be fully loaded and buffered before proceeding
    // This ensures the transition plays smoothly on first use
    const mediaReady = await mediaPreloadPromise;
    console.log("[INIT] Media preload complete (ready:", mediaReady, "), elapsed:", Date.now() - mediaPreloadStartedAt, "ms");

    // Extra safety wait to ensure GIF is truly buffered in GPU/memory
    await new Promise(r => setTimeout(r, 500));

    console.log("[INIT] Showing transition");
    showTransition();

    // fetch clip list, but do not block forever
    let data = null;
    console.log("[INIT] Fetching clip list from:", apiUrl);
    try {
      data = await Promise.race([
        fetch(apiUrl, { cache: "no-store" }).then(r => r.json()),
        new Promise((_, rej) => setTimeout(() => rej(new Error("clip list timeout")), 9000))
      ]);
      console.log("[INIT] Clip list fetched, count:", data?.clips?.length || 0);
    } catch (err) {
      console.error("[INIT] FAILED to fetch clip list:", err);
      return;
    }

    clips = Array.isArray(data.clips) ? data.clips : [];
    if (!clips.length) {
      console.error("[INIT] No clips in response, aborting");
      return;
    }

    const first = pickNextClip();
    if (!first) {
      console.error("[INIT] pickNextClip returned null, aborting");
      return;
    }
    console.log("[INIT] First clip selected:", first.id, first.title);

    liveFrame.classList.remove("live");

    const loadStartedAt = Date.now();
    console.log("[INIT] Loading first clip into iframe...");
    bindOnloadWithFailsafe(liveFrame, (wasFailsafe) => {
      console.log("[INIT] Iframe loaded (failsafe=%s), revealing...", wasFailsafe);
      revealIframeThenFadeOut(liveFrame, loadStartedAt);
      markPlayed(first);
      updateHudSeqLocal(first);  // Update HUD immediately from local data
      setNowPlayingWithRetry(first);

      try { backFrame.src = "about:blank"; } catch {}

      // Ensure valid duration
      const dur = (first.duration && first.duration > 0) ? first.duration : 30;
      scheduleNext(dur);
      console.log("[INIT] Scheduled next clip in", dur, "seconds (clip duration was:", first.duration, ")");

      if (fastMode) setTimeout(preloadNext, 900);

      hasStartedPlayback = true;
      isSwitching = false;

      if (pendingForced && pendingForced.clip) {
        const c = pendingForced.clip;
        pendingForced = null;
        switchToClip(c);
      }
      console.log("[INIT] Playback started successfully!");
    });

    liveFrame.src = clipSrc(first.id, true);
    console.log("[INIT] Iframe src set to:", liveFrame.src);

    startPclipPolling();
    console.log("[INIT] pclip polling started");

    setInterval(async () => {
      try {
        const r = await fetch(apiUrl, { cache: "no-store" });
        const d = await r.json();
        if (Array.isArray(d.clips) && d.clips.length) clips = d.clips;
      } catch {}
    }, 10 * 60 * 1000);
  }

  init();
})();
</script>
</body>
</html>
