<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FloppyJimmie MP4 Reel</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }

    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
    }

    #loadingOverlay {
      position: absolute;
      inset: 0;
      z-index: 99999;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 1;
      transition: opacity 400ms ease-out;
    }
    #loadingOverlay.hide { opacity: 0; pointer-events: none; }
    #loadingOverlay .content { text-align: center; color: #fff; font: 600 24px/1.4 system-ui, sans-serif; }
    #loadingOverlay .spinner {
      width: 48px; height: 48px; border-radius: 50%;
      border: 4px solid rgba(255,255,255,0.2); border-top-color: #fff;
      margin: 0 auto 20px; animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #voteHud {
      position: absolute;
      right: 24px;
      top: 24px;
      bottom: auto;
      left: auto;
      z-index: 11000;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      padding: 18px 24px;
      border-radius: 16px;
      background: rgba(0,0,0,0.25);
      border: 2px solid rgba(255,255,255,0.15);
      color: #fff;
      font: 18px/1.3 system-ui, sans-serif;
      backdrop-filter: blur(12px);
      opacity: 0;
      transform: translateX(6px);
      transition: opacity 180ms, transform 180ms, top 300ms ease, bottom 300ms ease, left 300ms ease, right 300ms ease;
      box-shadow: 0 4px 24px rgba(0,0,0,0.6);
      max-width: 550px;
      text-align: center;
      pointer-events: none;
    }
    #voteHud.show { opacity: 1; transform: translateX(0); }
    /* HUD positions */
    #voteHud.pos-tr { top: 24px !important; right: 24px !important; bottom: auto !important; left: auto !important; transform: translateX(6px); }
    #voteHud.pos-tr.show { transform: translateX(0); }
    #voteHud.pos-tl { top: 24px !important; left: 24px !important; bottom: auto !important; right: auto !important; transform: translateX(-6px); }
    #voteHud.pos-tl.show { transform: translateX(0); }
    #voteHud.pos-br { bottom: 24px !important; right: 24px !important; top: auto !important; left: auto !important; transform: translateX(6px); }
    #voteHud.pos-br.show { transform: translateX(0); }
    #voteHud.pos-bl { bottom: 24px !important; left: 24px !important; top: auto !important; right: auto !important; transform: translateX(-6px); }
    #voteHud.pos-bl.show { transform: translateX(0); }
    #voteHud .clip-info { display: flex; flex-direction: column; gap: 6px; width: 100%; align-items: center; }
    #voteHud .seq { font-weight: 800; font-size: 24px; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.7); }
    #voteHud .clip-date-hud { font-weight: 600; font-size: 18px; color: #a0a0ff; margin-left: 10px; }
    #voteHud .clip-title { font-weight: 600; font-size: 18px; color: #f0f0f0; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    #voteHud .clip-meta { font-size: 17px; font-weight: 600; color: #e8e8e8; display: flex; gap: 14px; justify-content: center; flex-wrap: wrap; }
    #voteHud .meta-duration { color: #fbbf24; }
    #voteHud .meta-category { color: #22d3ee; }
    #voteHud .meta-clipper-label { color: #a0a0a0; }
    #voteHud .meta-clipper-name { color: #c084fc; }
    #voteHud .vote-section { display: flex; gap: 14px; align-items: center; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); width: 100%; justify-content: center; }
    #voteHud .pill { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; border-radius: 999px; font-weight: 700; font-size: 18px; }
    #voteHud .pill.up { background: rgba(34,197,94,0.2); border: 2px solid rgba(34,197,94,0.6); color: #4ade80; }
    #voteHud .pill.down { background: rgba(239,68,68,0.2); border: 2px solid rgba(239,68,68,0.6); color: #f87171; }
    #voteHud .hints { display: flex; flex-direction: column; gap: 3px; font-size: 16px; font-weight: 700; }
    #voteHud .hint-like { color: #4ade80; }
    #voteHud .hint-dislike { color: #f87171; }

    #debugOverlay {
      position: absolute;
      right: 10px;
      bottom: 10px;
      z-index: 999999;
      background: rgba(0,0,0,0.95);
      color: #0f0;
      font: 12px/1.4 monospace;
      padding: 10px 12px;
      border-radius: 6px;
      border: 2px solid #0f0;
      max-width: 450px;
      max-height: 250px;
      overflow: hidden;
      display: none;
      pointer-events: none;
    }
    #debugOverlay.show { display: block; }
    #debugOverlay .ok { color: #4ade80; }
    #debugOverlay .err { color: #f87171; }
    #debugOverlay .warn { color: #fbbf24; }

    /* Top Clips Overlay */
    #topClipsOverlay {
      position: absolute;
      right: 24px;
      bottom: 24px;
      top: auto;
      left: auto;
      z-index: 12000;
      background: rgba(0,0,0,0.85);
      border: 2px solid rgba(255,215,0,0.6);
      border-radius: 16px;
      padding: 16px 20px;
      color: #fff;
      font: 16px/1.4 system-ui, sans-serif;
      backdrop-filter: blur(12px);
      box-shadow: 0 4px 24px rgba(0,0,0,0.8);
      min-width: 280px;
      max-width: 400px;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 300ms ease-out, transform 300ms ease-out, top 300ms ease, bottom 300ms ease, left 300ms ease, right 300ms ease;
      pointer-events: none;
    }
    #topClipsOverlay.show {
      opacity: 1;
      transform: translateY(0);
    }
    /* Top Clips Overlay positions */
    #topClipsOverlay.pos-tr { top: 24px !important; right: 24px !important; bottom: auto !important; left: auto !important; }
    #topClipsOverlay.pos-tl { top: 24px !important; left: 24px !important; bottom: auto !important; right: auto !important; }
    #topClipsOverlay.pos-br { bottom: 24px !important; right: 24px !important; top: auto !important; left: auto !important; }
    #topClipsOverlay.pos-bl { bottom: 24px !important; left: 24px !important; top: auto !important; right: auto !important; }
    #topClipsOverlay .header {
      font-size: 20px;
      font-weight: 800;
      color: #ffd700;
      margin-bottom: 12px;
      text-align: center;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    #topClipsOverlay .clip-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    #topClipsOverlay .clip-row:last-child {
      border-bottom: none;
    }
    #topClipsOverlay .rank {
      font-size: 18px;
      font-weight: 800;
      color: #ffd700;
      min-width: 28px;
      text-align: center;
    }
    #topClipsOverlay .rank.gold { color: #ffd700; }
    #topClipsOverlay .rank.silver { color: #c0c0c0; }
    #topClipsOverlay .rank.bronze { color: #cd7f32; }
    #topClipsOverlay .clip-info {
      flex: 1;
      overflow: hidden;
    }
    #topClipsOverlay .clip-seq {
      font-weight: 700;
      color: #a0a0ff;
      margin-right: 6px;
    }
    #topClipsOverlay .clip-title {
      color: #f0f0f0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #topClipsOverlay .clip-votes {
      display: flex;
      gap: 8px;
      font-weight: 700;
      font-size: 14px;
    }
    #topClipsOverlay .votes-up { color: #4ade80; }
    #topClipsOverlay .votes-down { color: #f87171; }
    #topClipsOverlay .net-score { color: #fbbf24; font-weight: 800; }
  </style>
</head>
<body>
  <video id="player" playsinline preload="auto"></video>

  <div id="voteHud">
    <div class="clip-info">
      <div style="display:flex;align-items:baseline;justify-content:center;gap:0;">
        <span class="seq" id="voteSeq">Clip</span>
        <span class="clip-date-hud" id="clipDateHud"></span>
      </div>
      <span class="clip-title" id="clipTitle"></span>
      <span class="clip-meta" id="clipMeta"></span>
    </div>
    <div class="vote-section">
      <span class="pill up" id="voteUp">üëç 0</span>
      <span class="pill down" id="voteDown">üëé 0</span>
      <div class="hints">
        <span class="hint-like" id="hintLike">!like #</span>
        <span class="hint-dislike" id="hintDislike">!dislike #</span>
      </div>
    </div>
  </div>

  <div id="loadingOverlay">
    <div class="content">
      <div class="spinner"></div>
      <div class="text">Loading Clips...</div>
    </div>
  </div>

  <div id="debugOverlay"></div>

  <div id="topClipsOverlay">
    <div class="header">Top Clips</div>
    <div id="topClipsList"></div>
  </div>

<script>
(() => {
  const qs = new URLSearchParams(location.search);

  const login  = (qs.get("login") || "floppyjimmie").toLowerCase();
  const days   = parseInt(qs.get("days") || "0", 10);  // 0 = all time
  const pool   = parseInt(qs.get("pool") || "300", 10);  // ~2 hours of clips, refreshed every 10 min
  const forceMuted = qs.get("muted") === "1";
  const instance = qs.get("instance") || "";  // Optional instance ID for multi-player isolation

  const API_BASE = "https://clipsystem-production.up.railway.app";
  const apiUrl = `${API_BASE}/twitch_reel_api.php?login=${encodeURIComponent(login)}&days=${days}&pool=${pool}`;

  // Twitch GQL for MP4 URLs
  const GQL_URL = "https://gql.twitch.tv/gql";
  const CLIENT_ID = "kimne78kx3ncx6brgo4mv6wki5h1ko";
  const QUERY_HASH = "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11";

  const RECENT_BLOCK = Math.max(10, Math.floor(pool * 0.20));
  const storageKey = `away_reel_state_${login}`;

  const player = document.getElementById("player");
  const loadingOverlay = document.getElementById("loadingOverlay");
  const voteHud = document.getElementById("voteHud");
  const voteSeq = document.getElementById("voteSeq");
  const clipDateHud = document.getElementById("clipDateHud");
  const clipTitle = document.getElementById("clipTitle");
  const clipMeta = document.getElementById("clipMeta");
  const voteUp = document.getElementById("voteUp");
  const voteDown = document.getElementById("voteDown");
  const hintLike = document.getElementById("hintLike");
  const hintDislike = document.getElementById("hintDislike");

  player.muted = forceMuted;

  // HUD Position polling
  const hudEnabled = qs.get("hud") !== "0";
  let currentHudPosition = null;
  let currentTopPosition = null;
  const topClipsOverlay = document.getElementById("topClipsOverlay");

  function setHudPosition(pos, force = false) {
    const validPositions = ['tr', 'tl', 'br', 'bl'];
    if (!validPositions.includes(pos)) pos = 'tr';
    if (!force && pos === currentHudPosition) return;

    currentHudPosition = pos;
    voteHud.classList.remove('pos-tr', 'pos-tl', 'pos-br', 'pos-bl');
    voteHud.classList.add(`pos-${pos}`);
    console.log('[HUD] Position set to:', pos);
  }

  function setTopPosition(pos, force = false) {
    const validPositions = ['tr', 'tl', 'br', 'bl'];
    if (!validPositions.includes(pos)) pos = 'br';
    if (!force && pos === currentTopPosition) return;

    currentTopPosition = pos;
    topClipsOverlay.classList.remove('pos-tr', 'pos-tl', 'pos-br', 'pos-bl');
    topClipsOverlay.classList.add(`pos-${pos}`);
    console.log('[TOP] Position set to:', pos);
  }

  async function pollHudPosition() {
    if (!hudEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/hud_position.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (data) {
        if (data.hud_position || data.position) {
          setHudPosition(data.hud_position || data.position, currentHudPosition === null);
        }
        if (data.top_position) {
          setTopPosition(data.top_position, currentTopPosition === null);
        }
      }
    } catch (e) {
      console.error('[HUD] Poll error:', e);
      if (currentHudPosition === null) setHudPosition('tr', true);
      if (currentTopPosition === null) setTopPosition('br', true);
    }
  }

  if (hudEnabled) {
    pollHudPosition();
    setInterval(pollHudPosition, 2000);
  }

  // Debug
  const debugEnabled = qs.get("debug") === "1";
  const debugOverlay = document.getElementById("debugOverlay");
  const debugLines = [];

  function debugLog(msg, type = "info") {
    if (!debugEnabled) return;
    const time = new Date().toLocaleTimeString("en-US", { hour12: false });
    debugLines.push({ time, msg, type });
    if (debugLines.length > 25) debugLines.shift();
    debugOverlay.classList.add("show");
    debugOverlay.innerHTML = debugLines.map(l => `<div class="${l.type}">${l.time} ${l.msg}</div>`).join("");
  }

  // State
  let clips = [];
  let voteScores = {};
  let currentClip = null;
  let failedClips = new Set();
  let isSwitching = false;
  let advanceTimer = null;
  let clipHistory = []; // Stack of previously played clips for !cprev
  const MAX_HISTORY = 20;

  // Category filter state
  let categoryFilter = null; // { game_id, game_name, clip_ids: Set }
  let lastCategoryNonce = null;

  // HUD poll interval (hudEnabled already declared above for position polling)
  const hudPollMs = parseInt(qs.get("hudpoll") || "900", 10);

  function formatDuration(s) {
    if (!s || s <= 0) return "";
    s = Math.round(s);
    return s < 60 ? `${s}s` : `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
  }

  function formatDate(d) {
    if (!d) return "";
    try {
      return new Date(d).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
    } catch { return ""; }
  }

  function updateHud(clip) {
    if (!hudEnabled || !clip) return;
    const seq = clip.seq || 0;
    voteSeq.textContent = `Clip #${seq}`;
    hintLike.textContent = `!like ${seq}`;
    hintDislike.textContent = `!dislike ${seq}`;
    clipDateHud.textContent = formatDate(clip.created_at) ? `‚Ä¢ ${formatDate(clip.created_at)}` : "";
    clipTitle.textContent = clip.title || "";

    const meta = [];
    const dur = formatDuration(clip.duration);
    if (dur) meta.push(`<span class="meta-duration">${dur}</span>`);
    if (clip.game_name) meta.push(`<span class="meta-category">${clip.game_name}</span>`);
    if (clip.creator_name) meta.push(`<span><span class="meta-clipper-label">Clipped by</span> <span class="meta-clipper-name">${clip.creator_name}</span></span>`);
    clipMeta.innerHTML = meta.join("");
    voteHud.classList.add("show");
  }

  async function pollVotes() {
    if (!hudEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/vote_status.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      voteUp.textContent = `üëç ${data?.up || 0}`;
      voteDown.textContent = `üëé ${data?.down || 0}`;
    } catch {}
  }

  // Persistence
  function loadState() { try { return JSON.parse(localStorage.getItem(storageKey) || "{}"); } catch { return {}; } }
  function saveState(s) { localStorage.setItem(storageKey, JSON.stringify(s)); }

  // GQL: Get MP4 URL with timeout
  async function getMp4Url(clipId) {
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 8000); // 8 second timeout

      const res = await fetch(GQL_URL, {
        method: "POST",
        headers: { "Client-ID": CLIENT_ID, "Content-Type": "application/json" },
        body: JSON.stringify({
          operationName: "VideoAccessToken_Clip",
          variables: { slug: clipId },
          extensions: { persistedQuery: { version: 1, sha256Hash: QUERY_HASH } }
        }),
        signal: controller.signal
      });
      clearTimeout(timeout);

      if (!res.ok) return null;
      const data = await res.json();
      const clip = data?.data?.clip;
      if (!clip) return null;

      const token = clip.playbackAccessToken?.value;
      const sig = clip.playbackAccessToken?.signature;
      const qualities = clip.videoQualities || [];
      if (!token || !sig || !qualities.length) return null;

      const best = qualities.sort((a,b) => (parseInt(b.quality)||0) - (parseInt(a.quality)||0))[0];
      const sep = best.sourceURL.includes("?") ? "&" : "?";
      return `${best.sourceURL}${sep}sig=${encodeURIComponent(sig)}&token=${encodeURIComponent(token)}`;
    } catch (e) {
      debugLog("GQL err: " + e.message, "err");
      return null;
    }
  }

  // Weighted selection
  function pickNextClip() {
    const state = loadState();
    state.recent = Array.isArray(state.recent) ? state.recent : [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};

    const recentSet = new Set(state.recent.slice(-RECENT_BLOCK));

    // Use current clips array (already filtered if category mode is active)
    let pool = clips;

    // Exclude recent and failed clips
    const candidates = pool.filter(c => !recentSet.has(c.id) && !failedClips.has(c.id));
    const usable = candidates.length ? candidates : pool.filter(c => !failedClips.has(c.id));

    if (!usable.length) {
      // All clips failed or blocked, reset failed set
      failedClips.clear();
      return clips[Math.floor(Math.random() * clips.length)];
    }

    const scored = usable.map(c => {
      const plays = state.playCounts[c.id] || 0;
      const lastAt = state.lastPlayedAt[c.id] || 0;
      const minutesAgo = (Date.now() - lastAt) / 60000;

      let score = 1;
      score += Math.min(5, minutesAgo / 15);
      score += Math.max(0, 3 - plays);

      const views = Number(c.view_count || 0);
      score += Math.min(1.8, Math.log10(views + 1) * 0.55);

      const netVotes = voteScores[c.id] || 0;
      score += Math.max(-5, Math.min(5, netVotes * 0.5));

      return { c, score };
    }).filter(x => x.score > 0.1);

    scored.sort((a,b) => b.score - a.score);
    const top = scored.slice(0, 25);

    const total = top.reduce((s,x) => s + x.score, 0);
    let r = Math.random() * total;
    for (const x of top) { r -= x.score; if (r <= 0) return x.c; }
    return top[0]?.c || usable[0];
  }

  function markPlayed(c) {
    const state = loadState();
    state.recent = state.recent || [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};

    state.recent.push(c.id);
    if (state.recent.length > 2000) state.recent = state.recent.slice(-800);
    state.playCounts[c.id] = (state.playCounts[c.id] || 0) + 1;
    state.lastPlayedAt[c.id] = Date.now();
    saveState(state);
  }

  // Now playing
  async function setNowPlaying(c) {
    if (!c?.id) return;
    try {
      await fetch(`${API_BASE}/now_playing_set.php`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ login, clip_id: c.id, seq: c.seq, title: c.title, duration: c.duration, view_count: c.view_count })
      });
    } catch {}
  }

  // Report clip play to server for rotation tracking
  async function reportClipPlayed(c) {
    if (!c?.id) return;
    try {
      await fetch(`${API_BASE}/clip_played.php?login=${encodeURIComponent(login)}&clip_id=${encodeURIComponent(c.id)}`, {
        cache: "no-store"
      });
    } catch {}
  }

  // Play clip with robust timeout handling
  let loadTimeout = null;
  let stallTimeout = null;
  let bufferCheckInterval = null;
  let isFirstClip = true; // Track first clip for extra buffering
  let isCommandTriggered = false; // Track if playback was triggered by !pclip or !cskip

  function clearVideoTimeouts() {
    if (loadTimeout) { clearTimeout(loadTimeout); loadTimeout = null; }
    if (stallTimeout) { clearTimeout(stallTimeout); stallTimeout = null; }
    if (bufferCheckInterval) { clearInterval(bufferCheckInterval); bufferCheckInterval = null; }
  }

  let playbackStarted = false; // Track if video has actually started playing

  let stallRecoveryAttempts = 0;

  function resetStallTimer() {
    if (stallTimeout) clearTimeout(stallTimeout);
    // Only set stall timer if playback has actually started
    if (!playbackStarted) return;
    // Check every 8 seconds if video is progressing
    stallTimeout = setTimeout(() => {
      const buffered = player.buffered.length > 0 ? player.buffered.end(0) : 0;
      const currentTime = player.currentTime || 0;
      const bufferAhead = buffered - currentTime;

      if (bufferAhead > 0.5) {
        // We have buffer - video should be playing
        // Check if video is actually paused/frozen
        if (player.paused || player.readyState < 3) {
          stallRecoveryAttempts++;
          debugLog(`Stall recovery attempt ${stallRecoveryAttempts}: paused=${player.paused}, ready=${player.readyState}`, "warn");

          if (stallRecoveryAttempts >= 3) {
            // Too many recovery attempts, skip this clip
            debugLog("Too many stall recoveries, skipping", "err");
            failedClips.add(currentClip?.id);
            isSwitching = false;
            playNext();
            return;
          }

          // Force play
          player.play().catch(() => {});
        }
        debugLog(`Stall check: ${bufferAhead.toFixed(1)}s ahead, continuing`, "warn");
        resetStallTimer();
        return;
      }

      // No buffer ahead - truly stalled
      debugLog("Video stalled (no buffer), skipping", "warn");
      failedClips.add(currentClip?.id);
      isSwitching = false;
      playNext();
    }, 8000);
  }

  async function playClip(c, skipHistory = false) {
    if (!c) return;
    isSwitching = true;
    // Save current clip to history (unless going back or first clip)
    if (currentClip && !skipHistory) {
      clipHistory.push(currentClip);
      if (clipHistory.length > MAX_HISTORY) clipHistory.shift();
    }
    currentClip = c;
    playbackStarted = false; // Reset - not playing yet
    stallRecoveryAttempts = 0; // Reset recovery counter
    clearVideoTimeouts();
    debugLog(`Loading: ${c.id.substring(0,20)}...`);

    // Use preloaded URL if available for this clip
    let mp4Url = null;
    let hasPreloadedBuffer = false;
    debugLog(`Checking preload: clip=${c.id.substring(0,15)}, preloadedClip=${preloadedClip?.id?.substring(0,15) || 'null'}`);
    if (preloadedClip && preloadedClip.id === c.id && preloadedMp4Url) {
      mp4Url = preloadedMp4Url;
      // Check if preload video has buffer we can use
      if (preloadVideo && preloadVideo.buffered.length > 0) {
        hasPreloadedBuffer = true;
        const buffered = preloadVideo.buffered.end(0);
        debugLog(`Using preloaded buffer (${buffered.toFixed(1)}s)`, "ok");
      } else {
        debugLog("Using preloaded URL (no buffer)", "warn");
      }
      preloadedClip = null;
      preloadedMp4Url = null;
    } else {
      debugLog(`Preload miss - fetching fresh URL`);
      mp4Url = await getMp4Url(c.id);
      cleanupPreloadVideo(); // Clean up any stale preload
    }

    if (!mp4Url) {
      debugLog(`No MP4 for ${c.id}`, "err");
      failedClips.add(c.id);
      isSwitching = false;
      playNext();
      return;
    }

    // Clear old handlers
    player.oncanplay = null;
    player.onerror = null;
    player.onplaying = null;
    player.ontimeupdate = null;
    player.onstalled = null;
    player.onwaiting = null;
    player.onprogress = null;
    player.onloadstart = null;

    player.src = mp4Url;

    // Log loading events for debugging
    player.onloadstart = () => {
      debugLog("Load started...");
    };

    player.onprogress = () => {
      // This fires as data downloads - helps ensure loading is active
      if (player.buffered.length > 0) {
        const buffered = player.buffered.end(0);
        if (buffered > 0 && buffered < 1) {
          debugLog(`Progress: ${buffered.toFixed(2)}s`);
        }
      }
    };

    player.load();

    // Track if browser thinks it can play through without buffering
    let canPlayThroughFired = false;
    player.oncanplaythrough = () => {
      canPlayThroughFired = true;
      debugLog("canplaythrough fired", "ok");
    };

    // For first clip, wait for more buffer before playing
    const startPlayback = () => {
      clearTimeout(loadTimeout);
      loadTimeout = null;

      player.play().then(() => {
        debugLog(`Playing: ${c.title?.substring(0,30) || c.id}`, "ok");
        loadingOverlay.classList.add("hide");
        updateHud(c);
        markPlayed(c);
        setNowPlaying(c);
        reportClipPlayed(c); // Report to server for rotation tracking
        scheduleNext(c.duration || 30);
        isSwitching = false;
        isFirstClip = false;
        isCommandTriggered = false; // Reset command flag after playback starts
        playbackStarted = true; // NOW we're actually playing
        resetStallTimer();
      }).catch(err => {
        debugLog(`Play err: ${err.message}`, "err");
        clearVideoTimeouts();
        failedClips.add(c.id);
        isSwitching = false;
        playNext();
      });
    };

    // Buffer requirements - keep it simple
    // - Preloaded clip: 2s (browser cache should make this fast)
    // - First clip (not preloaded): 8s buffer
    // - Command-triggered: 4s buffer
    // - Normal progression: 2s buffer
    const clipDur = c.duration || 30;
    let requiredBuffer = 2;
    if (hasPreloadedBuffer) {
      requiredBuffer = 2; // Preloaded - browser cache will help, minimal wait
    } else if (isFirstClip) {
      requiredBuffer = 8;
    } else if (isCommandTriggered) {
      requiredBuffer = 4;
    }
    debugLog(`Waiting for ${requiredBuffer}s buffer (first=${isFirstClip}, cmd=${isCommandTriggered}, preloaded=${hasPreloadedBuffer})...`);

    // Cleanup preload video after setting main player src (browser should cache the data)
    if (hasPreloadedBuffer) {
      // Small delay to let browser register the cache
      setTimeout(() => cleanupPreloadVideo(), 500);
    }
    let hasStarted = false;

    // Clear any existing buffer check
    if (bufferCheckInterval) { clearInterval(bufferCheckInterval); bufferCheckInterval = null; }

    let lastLoggedBuffer = 0;
    const checkBuffer = () => {
      if (hasStarted) return;
      if (player.buffered.length > 0) {
        const bufferedEnd = player.buffered.end(0);
        const clipDuration = c.duration || player.duration || 30;
        // readyState: 0=nothing, 1=metadata, 2=current, 3=future, 4=enough
        const readyState = player.readyState;
        // Start if we have enough buffer OR if we've buffered the entire clip
        const hasEnoughBuffer = bufferedEnd >= requiredBuffer;
        const hasFullClip = bufferedEnd >= (clipDuration - 0.5);

        // Just need readyState >= 3 (HAVE_FUTURE_DATA) to start
        const browserReady = readyState >= 3;

        if ((hasEnoughBuffer || hasFullClip) && browserReady) {
          hasStarted = true;
          clearInterval(bufferCheckInterval);
          debugLog(`Buffered: ${bufferedEnd.toFixed(1)}s (needed ${requiredBuffer}s, ready=${readyState})`, "ok");
          // On first clip without preload, wait 1s for network to stabilize
          if (isFirstClip && !hasPreloadedBuffer) {
            debugLog("Stabilizing (1s)...");
            setTimeout(() => {
              const finalBuffer = player.buffered.length > 0 ? player.buffered.end(0) : 0;
              debugLog(`Final buffer: ${finalBuffer.toFixed(1)}s`);
              // Just need 4s minimum to start
              if (finalBuffer >= 4) {
                startPlayback();
              } else {
                debugLog(`Buffer dropped to ${finalBuffer.toFixed(1)}s, re-buffering...`, "warn");
                hasStarted = false;
                bufferCheckInterval = setInterval(checkBuffer, 200);
              }
            }, 1000);
          } else {
            startPlayback();
          }
        } else {
          // Only log every 2s of buffer progress to reduce spam
          if (bufferedEnd - lastLoggedBuffer >= 2) {
            debugLog(`Buffering: ${bufferedEnd.toFixed(1)}s / ${requiredBuffer}s (ready=${readyState})`);
            lastLoggedBuffer = bufferedEnd;
          }
        }
      } else {
        // No buffer yet, log current state
        debugLog(`Waiting for buffer... (ready=${player.readyState})`);
      }
    };

    bufferCheckInterval = setInterval(checkBuffer, 200);

    // Cleanup on timeout - 20s for first clip, 15s for others
    const loadTimeoutMs = isFirstClip ? 20000 : 15000;
    debugLog(`Load timeout: ${loadTimeoutMs / 1000}s`);
    loadTimeout = setTimeout(() => {
      if (hasStarted) return;
      clearInterval(bufferCheckInterval);
      debugLog(`Load timeout for ${c.id.substring(0,15)}`, "err");
      failedClips.add(c.id);
      player.src = "";
      isSwitching = false;
      playNext();
    }, loadTimeoutMs);

    // Reset stall timer on progress
    player.ontimeupdate = () => {
      resetStallTimer();
    };

    // Handle stall/waiting events - try to recover from freezes
    let waitingCount = 0;
    let lastWaitingTime = 0;

    player.onstalled = () => {
      debugLog("Video stalling...", "warn");
    };

    player.onwaiting = () => {
      if (!playbackStarted) return; // Don't count pre-playback waiting

      waitingCount++;
      const now = Date.now();
      debugLog(`Video buffering... (count=${waitingCount})`, "warn");

      // If we've been waiting multiple times in quick succession, try to recover
      if (waitingCount >= 3 && (now - lastWaitingTime) < 5000) {
        debugLog("Multiple stalls detected, attempting recovery...", "warn");
        waitingCount = 0;

        // Try to nudge playback by seeking slightly forward
        const currentTime = player.currentTime;
        const buffered = player.buffered.length > 0 ? player.buffered.end(0) : 0;

        if (buffered > currentTime + 0.5) {
          // We have buffer ahead, try seeking to it
          player.currentTime = currentTime + 0.1;
          player.play().catch(() => {});
          debugLog(`Seeked to ${(currentTime + 0.1).toFixed(1)}s`, "warn");
        }
      }
      lastWaitingTime = now;
    };

    // Reset waiting count when video is playing smoothly
    player.onplaying = () => {
      waitingCount = 0;
    };

    player.onerror = () => {
      debugLog(`Video error, skipping`, "err");
      clearVideoTimeouts();
      failedClips.add(c.id);
      isSwitching = false;
      playNext();
    };
  }

  function playNext() {
    if (isSwitching) return;
    const next = pickNextClip();
    if (next) playClip(next);
  }

  function scheduleNext(duration) {
    if (advanceTimer) clearTimeout(advanceTimer);
    const d = Math.max(6, duration || 20);
    debugLog(`Next in ${d}s`);
    advanceTimer = setTimeout(() => {
      debugLog("Advancing...");
      playNext();
    }, d * 1000);
  }

  // Video ended event (backup)
  player.onended = () => {
    debugLog("Video ended");
    clearVideoTimeouts();
    if (advanceTimer) clearTimeout(advanceTimer);
    playNext();
  };

  // Force play polling - persist nonce to avoid replaying on page reload
  const pclipEnabled = qs.get("pclip") !== "0";
  const pclipNonceKey = `pclip_nonce_${login}`;
  let lastPclipNonce = localStorage.getItem(pclipNonceKey) || null;

  // Clear force play on server after we start playing it
  async function clearForcePlay() {
    try {
      await fetch(`${API_BASE}/force_play_clear.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      debugLog("Force play cleared", "ok");
    } catch {}
  }

  // Top clips overlay (topClipsOverlay already declared above for position polling)
  const topClipsList = document.getElementById("topClipsList");
  let topClipsTimeout = null;
  let lastTopNonce = null;

  function showTopClips(clips, count) {
    if (!clips || !clips.length) return;

    let html = '';
    clips.forEach((clip, i) => {
      const rankClass = i === 0 ? 'gold' : (i === 1 ? 'silver' : (i === 2 ? 'bronze' : ''));
      const rankEmoji = i === 0 ? 'ü•á' : (i === 1 ? 'ü•à' : (i === 2 ? 'ü•â' : `#${i + 1}`));
      const title = clip.title || '(untitled)';
      const shortTitle = title.length > 35 ? title.substring(0, 35) + '...' : title;

      html += `
        <div class="clip-row">
          <span class="rank ${rankClass}">${rankEmoji}</span>
          <div class="clip-info">
            <span class="clip-seq">#${clip.seq}</span>
            <span class="clip-title">${shortTitle}</span>
          </div>
          <div class="clip-votes">
            <span class="net-score">+${clip.net_score}</span>
            <span class="votes-up">üëç${clip.up_votes}</span>
            <span class="votes-down">üëé${clip.down_votes}</span>
          </div>
        </div>
      `;
    });

    topClipsList.innerHTML = html;
    topClipsOverlay.querySelector('.header').textContent = `Top ${count} Clips`;
    topClipsOverlay.classList.add('show');

    // Auto-hide after 15 seconds
    if (topClipsTimeout) clearTimeout(topClipsTimeout);
    topClipsTimeout = setTimeout(() => {
      topClipsOverlay.classList.remove('show');
    }, 15000);

    debugLog(`Showing top ${clips.length} clips`, "ok");
  }

  // Shuffle nonce tracking
  let lastShuffleNonce = null;

  // Category filter state
  let originalClips = null; // Store original clips when entering category mode

  // Preloading - fetch next clip's MP4 URL AND pre-buffer video data
  let preloadedClip = null;
  let preloadedMp4Url = null;
  let preloadVideo = null; // Hidden video element for actual buffering

  function cleanupPreloadVideo() {
    if (preloadVideo) {
      preloadVideo.pause();
      preloadVideo.src = '';
      preloadVideo.load();
      preloadVideo = null;
    }
  }

  async function preloadNextClip() {
    const next = pickNextClip();
    if (!next || next.id === currentClip?.id || next.id === preloadedClip?.id) return;

    try {
      const mp4Url = await getMp4Url(next.id);
      if (mp4Url) {
        preloadedClip = next;
        preloadedMp4Url = mp4Url;

        // Actually pre-buffer the video using a hidden video element
        cleanupPreloadVideo();
        preloadVideo = document.createElement('video');
        preloadVideo.preload = 'auto';
        preloadVideo.muted = true;
        preloadVideo.src = mp4Url;
        preloadVideo.load(); // Start buffering

        debugLog(`Preloading: ${next.id.substring(0,15)}...`);

        // Wait for some buffer before declaring ready
        await new Promise((resolve) => {
          const checkBuffer = () => {
            if (preloadVideo && preloadVideo.buffered.length > 0) {
              const buffered = preloadVideo.buffered.end(0);
              if (buffered >= 4) { // At least 4 seconds buffered
                debugLog(`Preloaded ${buffered.toFixed(1)}s`, "ok");
                resolve();
                return;
              }
            }
            // Timeout after 5 seconds regardless
            setTimeout(resolve, 100);
          };
          preloadVideo.addEventListener('progress', checkBuffer);
          preloadVideo.addEventListener('canplay', () => resolve());
          setTimeout(resolve, 5000); // Max 5s wait
        });
      }
    } catch {}
  }

  // Consolidated polling - single endpoint for all commands (reduces 7 calls to 1)
  async function pollAll() {
    try {
      let pollUrl = `${API_BASE}/poll.php?login=${encodeURIComponent(login)}`;
      if (instance) pollUrl += `&instance=${encodeURIComponent(instance)}`;
      const res = await fetch(pollUrl, { cache: "no-store" });
      const data = await res.json();

      // Handle Skip
      if (data?.skip && !isSwitching) {
        debugLog("Skip requested", "warn");
        clearVideoTimeouts();
        if (advanceTimer) clearTimeout(advanceTimer);
        isCommandTriggered = true;
        preloadedClip = null; // Clear preload on skip
        preloadedMp4Url = null;
        playNext();
        return; // Don't process other commands if skipping
      }

      // Handle Prev
      if (data?.prev && !isSwitching) {
        if (clipHistory.length === 0) {
          debugLog("No previous clip", "warn");
        } else {
          const prevClip = clipHistory.pop();
          debugLog(`Going back to: ${prevClip.title?.substring(0,20) || prevClip.id}`, "warn");
          clearVideoTimeouts();
          if (advanceTimer) clearTimeout(advanceTimer);
          isCommandTriggered = true;
          preloadedClip = null;
          preloadedMp4Url = null;
          playClip(prevClip, true);
          return;
        }
      }

      // Handle Force Play
      if (pclipEnabled && data?.force_play) {
        const fp = data.force_play;
        if (fp.nonce && fp.nonce !== lastPclipNonce) {
          // Ignore stale commands (older than 30 seconds)
          if (fp.set_at) {
            const age = Date.now() - new Date(fp.set_at).getTime();
            if (age > 30000) {
              lastPclipNonce = fp.nonce;
              localStorage.setItem(pclipNonceKey, fp.nonce);
              clearForcePlay();
            } else {
              lastPclipNonce = fp.nonce;
              localStorage.setItem(pclipNonceKey, fp.nonce);

              let c = clips.find(x => x.id === fp.clip_id);
              if (!c && fp.clip) c = fp.clip;
              if (c) {
                debugLog(`Force play: ${c.id.substring(0,15)}`, "warn");
                clearVideoTimeouts();
                if (advanceTimer) clearTimeout(advanceTimer);
                clearForcePlay();
                isCommandTriggered = true;
                preloadedClip = null;
                preloadedMp4Url = null;
                playClip(c);
                return;
              }
            }
          }
        }
      }

      // Handle Shuffle
      if (data?.shuffle && data.shuffle.nonce !== lastShuffleNonce) {
        lastShuffleNonce = data.shuffle.nonce;
        debugLog("Shuffle requested, fetching fresh pool...", "warn");

        // Clear category filter if active
        if (categoryFilter) {
          categoryFilter = null;
          lastCategoryNonce = null;
          originalClips = null;
        }

        // Fetch fresh clips with cache-bust
        const shuffleUrl = `${apiUrl}&_=${Date.now()}`;
        const clipRes = await fetch(shuffleUrl, { cache: "no-store" });
        const clipData = await clipRes.json();
        if (Array.isArray(clipData.clips) && clipData.clips.length) {
          clips = clipData.clips;
          // Clear recent history to allow any clip
          const state = loadState();
          state.recent = [];
          saveState(state);
          debugLog(`Shuffled! New pool: ${clips.length} clips`, "ok");
          // Clear preload since pool changed
          preloadedClip = null;
          preloadedMp4Url = null;
        }
      }

      // Handle Category
      const cat = data?.category;
      if (cat) {
        if (!cat.active) {
          // Category filter cleared - restore original clips
          if (categoryFilter) {
            debugLog("Category filter cleared", "ok");
            if (originalClips) {
              clips = originalClips;
              originalClips = null;
              debugLog(`Restored ${clips.length} clips`);
            }
            categoryFilter = null;
            lastCategoryNonce = null;
            preloadedClip = null;
            preloadedMp4Url = null;
          }
        } else if (cat.nonce && cat.nonce !== lastCategoryNonce) {
          lastCategoryNonce = cat.nonce;

          // Store original clips if first time entering category mode
          if (!originalClips) {
            originalClips = clips;
          }

          // Replace clips with category-specific clips from server
          if (cat.clips && cat.clips.length > 0) {
            clips = cat.clips;
            debugLog(`Category: ${cat.game_name} - loaded ${clips.length} clips`, "ok");
          } else {
            // Fallback: filter existing clips by ID
            const catIds = new Set(cat.clip_ids || []);
            clips = originalClips.filter(c => catIds.has(c.id));
            debugLog(`Category: ${cat.game_name} - filtered to ${clips.length} clips`, "ok");
          }

          categoryFilter = {
            game_id: cat.game_id,
            game_name: cat.game_name,
            clip_ids: new Set(cat.clip_ids || [])
          };

          // Clear preload since pool changed
          preloadedClip = null;
          preloadedMp4Url = null;

          // If we were in the middle of switching, skip to new category clip
          if (!isSwitching && clips.length > 0) {
            clearVideoTimeouts();
            if (advanceTimer) clearTimeout(advanceTimer);
            isCommandTriggered = true;
            playNext();
          }
        }
      }

      // Handle Top Clips
      if (data?.top_clips?.active && data.top_clips.nonce !== lastTopNonce) {
        lastTopNonce = data.top_clips.nonce;
        showTopClips(data.top_clips.clips, data.top_clips.count);
      }

      // Update vote HUD from consolidated poll
      if (hudEnabled && data?.votes) {
        voteUp.textContent = `üëç ${data.votes.up || 0}`;
        voteDown.textContent = `üëé ${data.votes.down || 0}`;
      }

    } catch (e) {
      debugLog("Poll error: " + e.message, "err");
    }
  }

  // Init
  async function init() {
    debugLog("Init starting...");

    // Clear any previous playback state on browser refresh
    try {
      await fetch(`${API_BASE}/clear_playback_state.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      debugLog("Playback state cleared");
    } catch (e) {
      debugLog("Could not clear state: " + e.message, "warn");
    }

    // Fetch clips
    try {
      const res = await fetch(apiUrl, { cache: "no-store" });
      const data = await res.json();
      clips = Array.isArray(data.clips) ? data.clips : [];
      debugLog(`Loaded ${clips.length} clips`, "ok");
    } catch (e) {
      debugLog("Fetch failed: " + e.message, "err");
      return;
    }

    if (!clips.length) {
      debugLog("No clips!", "err");
      return;
    }

    // Fetch votes
    try {
      const res = await fetch(`${API_BASE}/votes_export.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (Array.isArray(data.votes)) {
        data.votes.forEach(v => { voteScores[v.clip_id] = v.net_score || 0; });
        debugLog(`Loaded ${Object.keys(voteScores).length} votes`);
      }
    } catch {}

    // Preload and start first clip BEFORE starting polling
    // This ensures no poll interference during initial load
    debugLog("Preloading first clip...");
    const first = pickNextClip();
    if (first) {
      debugLog(`Selected first clip: ${first.id.substring(0,20)}...`);
      try {
        const mp4Url = await getMp4Url(first.id);
        if (mp4Url) {
          // Pre-buffer the first clip's video data
          cleanupPreloadVideo();
          preloadVideo = document.createElement('video');
          preloadVideo.preload = 'auto';
          preloadVideo.muted = true;
          preloadVideo.src = mp4Url;
          preloadVideo.load();

          debugLog("Buffering first clip...");

          // Wait for at least 8 seconds buffered (or timeout)
          await new Promise((resolve) => {
            const checkBuffer = () => {
              if (preloadVideo && preloadVideo.buffered.length > 0) {
                const buffered = preloadVideo.buffered.end(0);
                if (buffered >= 8) {
                  debugLog(`First clip buffered: ${buffered.toFixed(1)}s`, "ok");
                  resolve();
                  return;
                }
              }
            };
            preloadVideo.addEventListener('progress', checkBuffer);
            preloadVideo.addEventListener('canplaythrough', () => {
              debugLog("canplaythrough fired for preload");
              resolve();
            });
            // Check periodically
            const interval = setInterval(() => {
              if (preloadVideo && preloadVideo.buffered.length > 0) {
                const buffered = preloadVideo.buffered.end(0);
                debugLog(`Preload buffer: ${buffered.toFixed(1)}s`);
                if (buffered >= 8) {
                  clearInterval(interval);
                  resolve();
                }
              }
            }, 500);
            setTimeout(() => { clearInterval(interval); debugLog("Preload timeout", "warn"); resolve(); }, 10000);
          });

          // Set preload state AFTER buffering complete, right before playClip
          preloadedClip = first;
          preloadedMp4Url = mp4Url;
          debugLog(`First clip ready, preloadedClip.id=${first.id.substring(0,15)}`, "ok");
        }
      } catch (e) {
        debugLog(`Preload error: ${e.message}`, "err");
      }
      // Play - video data is pre-buffered
      debugLog(`Starting playClip for ${first.id.substring(0,15)}...`);
      playClip(first);
    }

    // Start polling AFTER first clip begins (prevents interference)
    // 2s interval is sufficient for mod commands while reducing server load
    setInterval(pollAll, 2000);

    // Preload next clip at 70% through current clip
    setInterval(() => {
      if (currentClip && !preloadedClip && !isSwitching) {
        const currentTime = player.currentTime || 0;
        const duration = currentClip.duration || 30;
        if (currentTime > duration * 0.7) {
          preloadNextClip();
        }
      }
    }, 2000);

    // Refresh clips every 5 minutes for variety from full 14k+ catalog
    setInterval(async () => {
      try {
        const res = await fetch(apiUrl, { cache: "no-store" });
        const data = await res.json();
        if (Array.isArray(data.clips) && data.clips.length) {
          // Only update if not in category mode
          if (!categoryFilter) {
            clips = data.clips;
            debugLog(`Refreshed pool: ${clips.length} clips`);
            // Clear preload since pool refreshed
            preloadedClip = null;
            preloadedMp4Url = null;
          }
        }
      } catch {}
    }, 5 * 60 * 1000);
  }

  init();
})();
</script>
</body>
</html>
