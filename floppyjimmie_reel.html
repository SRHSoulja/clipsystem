<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FloppyJimmie Away Reel</title>

  <!-- Transition preloading is handled in JS - supports video (preferred) or GIF fallback -->
  <link rel="preload" as="video" href="/flop/transition.mp4" fetchpriority="high">
  <link rel="preload" as="video" href="/flop/transition.webm" fetchpriority="high">
  <link rel="preload" as="image" href="/flop/transition.gif" fetchpriority="high">

  <link rel="dns-prefetch" href="//clips.twitch.tv">
  <link rel="preconnect" href="https://clips.twitch.tv" crossorigin>
  <link rel="preconnect" href="https://gql.twitch.tv" crossorigin>
  <link rel="preconnect" href="https://static.twitchcdn.net" crossorigin>

  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    .stage { position: relative; width: 100%; height: 100%; overflow: hidden; }

    .viewport{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      z-index:1;
      background:#000;
    }

    .viewport .frameWrap{
      position:absolute;
      inset:0;
    }

    .viewport iframe{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      border:0;
      opacity:0;
      transition: opacity 820ms linear;
    }
    .viewport iframe.live{ opacity:1; }

    body.overscan .viewport iframe{
      transform: scale(1.08) translateY(-3%);
      transform-origin:center;
    }

    body.fakeMobile .viewport .frameWrap{
      width: 1500px;
      height: 1080px;
      inset: auto;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(var(--embed-scale, 1));
      transform-origin: center;
    }

    body.fakeMobile.overscan .viewport iframe{
      transform: none;
    }

    #transition{
      position:absolute;
      inset:0;
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:1;
      pointer-events:none;
      z-index:9999;
    }
    #transition.hide{
      opacity:0;
      transition: opacity 260ms linear;
    }

    #transitionImg, #transitionVideo{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }

    #ui-mask{
      position:absolute;
      left:0;
      right:0;
      bottom:0;
      height:64px;
      background:#000;
      z-index:10000;
      pointer-events:none;
      display:none;
    }
    body.mask #ui-mask{ display:block; }

    /* Simple loading overlay - shows briefly on fresh source load */
    #loadingOverlay{
      position:absolute;
      inset:0;
      z-index:99999;
      pointer-events:none;
      background: #000;
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:1;
      transition: opacity 400ms ease-out;
    }
    #loadingOverlay.hide{ opacity:0; pointer-events:none; }

    #loadingOverlay .content{
      text-align:center;
      color:#fff;
      font: 600 24px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    #loadingOverlay .spinner{
      width:48px;
      height:48px;
      border-radius:50%;
      border:4px solid rgba(255,255,255,0.2);
      border-top-color: #fff;
      margin: 0 auto 20px auto;
      animation: spin 0.8s linear infinite;
    }

    #loadingOverlay .text{
      opacity:0.9;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    #voteHud{
      position:absolute;
      z-index:11000;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      padding:18px 24px;
      border-radius:16px;
      background: rgba(0,0,0,0.25);
      border: 2px solid rgba(255,255,255,0.15);
      color:#fff;
      font: 18px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      user-select:none;
      pointer-events:none;
      backdrop-filter: blur(12px);
      opacity:0;
      transition: opacity 180ms linear, transform 180ms linear, top 300ms ease, bottom 300ms ease, left 300ms ease, right 300ms ease;
      box-shadow: 0 4px 24px rgba(0,0,0,0.6);
      max-width:550px;
      text-align:center;
      /* Default position: top-right */
      top:24px;
      right:24px;
      bottom:auto;
      left:auto;
      transform: translateX(6px);
    }
    #voteHud.show{
      opacity:1;
      transform: translateX(0);
    }
    /* HUD positions - use !important to override default positioning */
    #voteHud.pos-tr{ top:24px !important; right:24px !important; bottom:auto !important; left:auto !important; transform: translateX(6px); }
    #voteHud.pos-tr.show{ transform: translateX(0); }
    #voteHud.pos-tl{ top:24px !important; left:24px !important; bottom:auto !important; right:auto !important; transform: translateX(-6px); }
    #voteHud.pos-tl.show{ transform: translateX(0); }
    #voteHud.pos-br{ bottom:24px !important; right:24px !important; top:auto !important; left:auto !important; transform: translateX(6px); }
    #voteHud.pos-br.show{ transform: translateX(0); }
    #voteHud.pos-bl{ bottom:24px !important; left:24px !important; top:auto !important; right:auto !important; transform: translateX(-6px); }
    #voteHud.pos-bl.show{ transform: translateX(0); }
    #voteHud .clip-info{
      display:flex;
      flex-direction:column;
      gap:6px;
      width:100%;
      align-items:center;
    }
    #voteHud .seq{
      font-weight:800;
      font-size:24px;
      letter-spacing:.3px;
      color:#fff;
      text-shadow: 0 2px 4px rgba(0,0,0,0.7);
    }
    #voteHud .clip-date-hud{
      font-weight:600;
      font-size:18px;
      color:#a0a0ff;
      text-shadow: 0 2px 4px rgba(0,0,0,0.7);
      margin-left:10px;
    }
    #voteHud .clip-title{
      font-weight:600;
      font-size:18px;
      color:#f0f0f0;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    #voteHud .clip-meta{
      font-size:17px;
      font-weight:600;
      color:#e8e8e8;
      display:flex;
      gap:14px;
      justify-content:center;
      flex-wrap:wrap;
      text-shadow: 0 2px 4px rgba(0,0,0,0.7);
    }
    #voteHud .clip-meta span{
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    #voteHud .meta-duration{
      color:#fbbf24;
    }
    #voteHud .meta-category{
      color:#22d3ee;
    }
    #voteHud .meta-clipper-label{
      color:#a0a0a0;
    }
    #voteHud .meta-clipper-name{
      color:#c084fc;
    }
    #voteHud .vote-section{
      display:flex;
      gap:14px;
      align-items:center;
      padding-top:8px;
      border-top: 1px solid rgba(255,255,255,0.2);
      width:100%;
      justify-content:center;
    }
    #voteHud .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:8px 14px;
      border-radius:999px;
      font-weight:700;
      font-size:18px;
    }
    #voteHud .pill.up{
      background: rgba(34,197,94,0.2);
      border: 2px solid rgba(34,197,94,0.6);
      color: #4ade80;
    }
    #voteHud .pill.down{
      background: rgba(239,68,68,0.2);
      border: 2px solid rgba(239,68,68,0.6);
      color: #f87171;
    }
    #voteHud .hints{
      display:flex;
      flex-direction:column;
      gap:3px;
      font-size:16px;
      font-weight:700;
    }
    #voteHud .hint-like{
      color: #4ade80;
    }
    #voteHud .hint-dislike{
      color: #f87171;
    }

    /* Debug overlay - add ?debug=1 to URL to show */
    #debugOverlay{
      position:absolute;
      right:10px;
      bottom:10px;
      z-index:999999;
      background: rgba(0,0,0,0.95);
      color:#0f0;
      font: 12px/1.4 monospace;
      padding:10px 12px;
      border-radius:6px;
      border: 2px solid #0f0;
      max-width:450px;
      max-height:250px;
      overflow:hidden;
      display:none;
      pointer-events:none;
    }
    #debugOverlay.show{ display:block; }
    #debugOverlay .line{ margin:2px 0; }
    #debugOverlay .ok{ color:#4ade80; }
    #debugOverlay .err{ color:#f87171; }
    #debugOverlay .warn{ color:#fbbf24; }
  </style>
</head>

<body>
  <div class="stage">
    <div class="viewport" id="viewport">
      <div class="frameWrap">
        <iframe id="frameA" allow="autoplay; fullscreen" allowfullscreen></iframe>
        <iframe id="frameB" allow="autoplay; fullscreen" allowfullscreen></iframe>
      </div>
    </div>

    <div id="transition" class="hide" aria-hidden="true">
      <!-- Use video instead of GIF for reliable loading in OBS browser source -->
      <!-- If you have transition.mp4/webm, it will use that; falls back to GIF -->
      <video id="transitionVideo" muted playsinline loop preload="auto" style="display:none;">
        <source src="/flop/transition.webm" type="video/webm">
        <source src="/flop/transition.mp4" type="video/mp4">
      </video>
      <img id="transitionImg" src="/flop/transition.gif" alt="">
    </div>

    <div id="ui-mask"></div>

    <div id="voteHud" aria-hidden="true">
      <div class="clip-info">
        <div style="display:flex;align-items:baseline;justify-content:center;gap:0;">
          <span class="seq" id="voteSeq">Clip</span>
          <span class="clip-date-hud" id="clipDateHud"></span>
        </div>
        <span class="clip-title" id="clipTitle"></span>
        <span class="clip-meta" id="clipMeta"></span>
      </div>
      <div class="vote-section">
        <span class="pill up" id="voteUp">üëç 0</span>
        <span class="pill down" id="voteDown">üëé 0</span>
        <div class="hints">
          <span class="hint-like" id="hintLike">!like #</span>
          <span class="hint-dislike" id="hintDislike">!dislike #</span>
        </div>
      </div>
    </div>

    <div id="loadingOverlay" aria-hidden="true">
      <div class="content">
        <div class="spinner"></div>
        <div class="text">Loading Clips...</div>
      </div>
    </div>

    <div id="debugOverlay" aria-hidden="true"></div>
  </div>

<script>
(() => {
  const qs = new URLSearchParams(location.search);

  const login  = (qs.get("login") || "floppyjimmie").toLowerCase();
  const parent = qs.get("parent") || location.hostname;
  const days   = parseInt(qs.get("days") || "180", 10);
  const pool   = parseInt(qs.get("pool") || "400", 10);

  // Detect if this is a fresh page load vs returning to existing source
  // sessionStorage clears when browser source is refreshed/updated
  // We only skip boot if GIF was loaded THIS session (not from previous)
  const SESSION_KEY = `session_${login}`;
  const GIF_LOADED_KEY = `gif_loaded_${login}`;
  let gifLoadedThisSession = false;
  try {
    const currentSession = sessionStorage.getItem(SESSION_KEY);
    const gifLoaded = sessionStorage.getItem(GIF_LOADED_KEY);
    // Only consider cached if we have BOTH a session marker AND gif loaded marker
    // This means we've already successfully loaded the GIF in this exact browser session
    gifLoadedThisSession = !!(currentSession && gifLoaded);
    console.log("[INIT] Session exists:", !!currentSession, "GIF loaded:", !!gifLoaded, "Skip boot:", gifLoadedThisSession);

    // Always set session marker on load
    if (!currentSession) {
      sessionStorage.setItem(SESSION_KEY, String(Date.now()));
    }
  } catch {}

  const fastMode   = qs.get("fast") === "1";
  const fakeMobile = qs.get("mobile") === "1";
  const autostart  = qs.get("autostart") !== "0";  // Default true
  const forceMuted = qs.get("muted") === "1";      // Force muted if ?muted=1

  if (qs.get("overscan") === "1") document.body.classList.add("overscan");
  if (qs.get("mask") === "1") document.body.classList.add("mask");
  if (fakeMobile) document.body.classList.add("fakeMobile");

  // Railway API base URL
  const API_BASE = "https://clipsystem-production.up.railway.app";
  const apiUrl = `${API_BASE}/twitch_reel_api.php?login=${encodeURIComponent(login)}&days=${days}&pool=${pool}`;

  const RECENT_BLOCK = Math.max(10, Math.floor(pool * 0.20));
  const storageKey = `away_reel_state_${login}`;

  const viewport      = document.getElementById("viewport");
  const frameA        = document.getElementById("frameA");
  const frameB        = document.getElementById("frameB");
  const transition    = document.getElementById("transition");
  const transitionImg = document.getElementById("transitionImg");
  const transitionVideo = document.getElementById("transitionVideo");

  // Determine if we should use video or GIF for transitions
  // Video is preferred as it loads much more reliably in OBS browser source
  let useVideoTransition = false;

  const loadingOverlay = document.getElementById("loadingOverlay");

  // Show loading overlay on first load only (not when already loaded this session)
  // Refreshing/updating the browser source clears sessionStorage, so it shows again
  const showLoadingOnStart = !gifLoadedThisSession;

  // Debug overlay - add ?debug=1 to URL to show
  const debugEnabled = qs.get("debug") === "1";
  const debugOverlay = document.getElementById("debugOverlay");
  const debugLines = [];
  const MAX_DEBUG_LINES = 12;

  function debugLog(msg, type = "info") {
    if (!debugEnabled) return;
    const time = new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" });
    debugLines.push({ time, msg, type });
    if (debugLines.length > MAX_DEBUG_LINES) debugLines.shift();
    renderDebug();
  }

  function renderDebug() {
    if (!debugEnabled || !debugOverlay) return;
    debugOverlay.classList.add("show");
    debugOverlay.innerHTML = debugLines.map(l => {
      const cls = l.type === "ok" ? "ok" : l.type === "err" ? "err" : l.type === "warn" ? "warn" : "";
      return `<div class="line ${cls}">${l.time} ${l.msg}</div>`;
    }).join("");
  }

  // ===== Vote HUD polling =====
  const voteHud  = document.getElementById("voteHud");
  const voteSeq  = document.getElementById("voteSeq");
  const clipDateHud = document.getElementById("clipDateHud");
  const clipTitle = document.getElementById("clipTitle");
  const clipMeta = document.getElementById("clipMeta");
  const voteUp   = document.getElementById("voteUp");
  const voteDown = document.getElementById("voteDown");
  const hintLike = document.getElementById("hintLike");
  const hintDislike = document.getElementById("hintDislike");

  const hudEnabled = qs.get("hud") !== "0";
  const hudPollMs  = Math.max(350, Math.min(2500, parseInt(qs.get("hudpoll") || "900", 10)));

  // Client-side seq tracking - updates HUD immediately without waiting for server
  let currentHudSeq = 0;
  let currentHudClipId = null;
  let currentClip = null;

  // Helper: format duration as "Xs" or "M:SS"
  function formatDuration(seconds) {
    if (!seconds || seconds <= 0) return "";
    const s = Math.round(seconds);
    if (s < 60) return `${s}s`;
    const m = Math.floor(s / 60);
    const rem = s % 60;
    return `${m}:${rem.toString().padStart(2, '0')}`;
  }

  // Helper: format clip date
  function formatClipDate(dateStr) {
    if (!dateStr) return "";
    try {
      const d = new Date(dateStr);
      if (isNaN(d.getTime())) return "";
      return d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
    } catch {
      return "";
    }
  }

  // Update HUD seq immediately from local clip data (no server needed)
  function updateHudSeqLocal(clip) {
    if (!hudEnabled || !clip) return;

    currentClip = clip;

    // Get seq from clip object (set by index) or fallback to array position
    let seq = clip.seq;
    if (!seq && clips.length) {
      // Find clip position in array as fallback
      const idx = clips.findIndex(c => c.id === clip.id);
      if (idx >= 0) seq = idx + 1;
    }

    if (seq && seq > 0) {
      currentHudSeq = seq;
      currentHudClipId = clip.id;
      voteSeq.textContent = `Clip #${seq}`;
      hintLike.textContent = `!like ${seq}`;
      hintDislike.textContent = `!dislike ${seq}`;

      // Update clip date
      const dateStr = formatClipDate(clip.created_at);
      clipDateHud.textContent = dateStr ? `‚Ä¢ ${dateStr}` : "";

      // Update clip title
      clipTitle.textContent = clip.title || "";

      // Update clip meta (duration, category, clipper)
      const metaParts = [];
      const dur = formatDuration(clip.duration);
      if (dur) metaParts.push(`<span class="meta-duration">${dur}</span>`);
      if (clip.game_name) metaParts.push(`<span class="meta-category">${clip.game_name}</span>`);
      if (clip.creator_name) {
        metaParts.push(`<span><span class="meta-clipper-label">Clipped by</span> <span class="meta-clipper-name">${clip.creator_name}</span></span>`);
      }
      clipMeta.innerHTML = metaParts.join("");

      voteHud.classList.add("show");
      debugLog("HUD seq=" + seq + " (local)", "ok");
    }
  }

  // Render votes from server (seq comes from local tracking now)
  function renderHudVotes(data){
    if (!hudEnabled) return;

    // Only update vote counts, not seq (seq is tracked locally)
    voteUp.textContent = `üëç ${Number(data?.up || 0)}`;
    voteDown.textContent = `üëé ${Number(data?.down || 0)}`;
    voteHud.classList.add("show");
  }

  async function pollHudOnce(){
    if (!hudEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/vote_status.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      // Only use server seq if we don't have local tracking yet
      if (data && typeof data.seq === "number" && currentHudSeq === 0) {
        currentHudSeq = data.seq;
        voteSeq.textContent = `Clip #${data.seq}`;
        hintLike.textContent = `!like ${data.seq}`;
        hintDislike.textContent = `!dislike ${data.seq}`;
      }
      renderHudVotes(data);
    } catch {}
  }

  if (hudEnabled) {
    pollHudOnce();
    setInterval(pollHudOnce, hudPollMs);
  }

  // ===== HUD Position polling =====
  let currentHudPosition = null; // Will be set from API

  function setHudPosition(pos, force = false) {
    const validPositions = ['tr', 'tl', 'br', 'bl'];
    if (!validPositions.includes(pos)) pos = 'tr';
    if (!force && pos === currentHudPosition) return;

    currentHudPosition = pos;
    // Remove all position classes
    voteHud.classList.remove('pos-tr', 'pos-tl', 'pos-br', 'pos-bl');
    // Add new position class
    voteHud.classList.add(`pos-${pos}`);
    console.log('[HUD] Position set to:', pos);
  }

  async function pollHudPosition() {
    if (!hudEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/hud_position.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (data && data.position) {
        const isInitial = currentHudPosition === null;
        setHudPosition(data.position, isInitial);
      }
    } catch (e) {
      console.error('[HUD] Poll error:', e);
      // Set default if not yet set
      if (currentHudPosition === null) {
        setHudPosition('tr', true);
      }
    }
  }

  if (hudEnabled) {
    // Immediately fetch initial position from API
    pollHudPosition();
    // Poll for position changes every 2 seconds
    setInterval(pollHudPosition, 2000);
  }

  // ===== Simple loading overlay (replaces old matrix rain) =====
  // Show for 5-10 seconds on fresh source load, then fade out
  const LOADING_OVERLAY_MIN_MS     = 5000;   // Minimum 5 seconds display
  const LOADING_EXTRA_SETTLE_MS    = 1000;   // Extra settle after iframe loads
  const MEDIA_PRELOAD_MIN_MS       = 2000;   // Minimum time for video/GIF preload
  let loadingShownAt = 0;
  let mediaPreloadStartedAt = 0;

  // Show loading overlay on fresh source load
  if (showLoadingOnStart) {
    loadingShownAt = Date.now();
    loadingOverlay.classList.remove("hide");
    debugLog("LOADING: showing overlay");
  } else {
    loadingOverlay.classList.add("hide");
    debugLog("LOADING: skipped (session cached)");
  }

  function showLoadingOverlay(){
    if (!showLoadingOnStart) return;
    loadingOverlay.classList.remove("hide");
    if (loadingShownAt === 0) loadingShownAt = Date.now();
  }

  function hideLoadingOverlay(){
    loadingOverlay.classList.add("hide");
    debugLog("LOADING: hidden");
  }

  // ===== Timing knobs =====
  // TRANSITION_PREROLL_MS: How early (ms) before clip ends to show transition
  //   - Lower = transition starts closer to when clip actually ends
  //   - 0 = transition starts exactly when clip ends
  const TRANSITION_PREROLL_MS      = 0;

  // TRANSITION_MIN_MS: Minimum time (ms) the transition video/gif plays
  //   - Should roughly match your transition video length
  //   - Too short = cuts off mid-animation; Too long = delays next clip
  const TRANSITION_MIN_MS          = 10;

  // TRANSITION_AFTER_REVEAL_MS: Extra delay (ms) after new clip loads before hiding transition
  //   - Gives the new clip time to start playing smoothly
  const TRANSITION_AFTER_REVEAL_MS = 10;
  const IFRAME_LOAD_FAILSAFE_MS    = 8000;

  const IFRAME_SETTLE_PAD_MS       = 80;
  const LOAD_SLOW_THRESHOLD_MS     = 80;
  const LOAD_SLOW_EXTRA_MS         = 50;

  let transitionShownAt = 0;

  let liveFrame = frameA;
  let backFrame = frameB;

  let clips = [];
  let voteScores = {}; // clip_id -> net score (likes - dislikes)
  let advanceTimer = null;
  let transitionTimer = null;
  let prepareTimer = null;
  let playlistAdvanceTimer = null; // Timer for playlist auto-advance

  // Playlist mode state (from API response)
  let playlistMode = false;
  let playlistIndex = 0;
  let playlistTotal = 0;
  let playlistName = "";

  let nextClip = null;
  let nextToken = 0;

  let firstTransitionShown = false;

  // ===== RESUME / BLACK-SCREEN RECOVERY =====
  let hasStartedPlayback = false;
  let isSwitching = false;

  function anyLiveVisible(){
    return frameA.classList.contains("live") || frameB.classList.contains("live");
  }

  function recoverFromBlack(){
    if (!hasStartedPlayback) return;
    if (isSwitching) return;
    if (!transition.classList.contains("hide")) return;
    if (!anyLiveVisible() && clips.length) {
      showTransition();
    }
  }

  setInterval(recoverFromBlack, 700);

  function applyFakeMobileScale() {
    if (!fakeMobile) return;
    const baseW = 390, baseH = 844;
    const s = Math.min(window.innerWidth / baseW, window.innerHeight / baseH);
    viewport.style.setProperty("--embed-scale", String(s));
  }
  window.addEventListener("resize", applyFakeMobileScale);
  applyFakeMobileScale();

  function loadState() {
    try { return JSON.parse(localStorage.getItem(storageKey) || "{}"); }
    catch { return {}; }
  }
  function saveState(state) { localStorage.setItem(storageKey, JSON.stringify(state)); }
  function nowMs(){ return Date.now(); }

  const TRANSITION_GIF_BASE = "/flop/transition.gif";

  // ===== Transition gif restart that actually replays in OBS =====
  function restartGifHard(url){
    // Use blob URL if available (already in memory, no network request)
    // Fall back to regular URL otherwise
    const srcToUse = transitionGifBlobUrl || url;

    transitionImg.src = "";
    requestAnimationFrame(() => {
      transitionImg.src = srcToUse;
    });
  }

  // Preload the transition media (video preferred, GIF fallback)
  let transitionMediaReady = false;
  let transitionGifBlobUrl = null;

  // Try to load video first (much more reliable in OBS), fall back to GIF
  async function preloadTransitionMedia(){
    mediaPreloadStartedAt = Date.now();

    const minWait = gifLoadedThisSession ? 500 : MEDIA_PRELOAD_MIN_MS;
    console.log("[TRANSITION] Starting preload, session loaded:", gifLoadedThisSession, "minWait:", minWait);

    return new Promise((resolve) => {
      let resolved = false;
      const finish = (success, isVideo = false) => {
        if (resolved) return;
        resolved = true;

        if (success) {
          transitionMediaReady = true;
          useVideoTransition = isVideo;
          try { sessionStorage.setItem(GIF_LOADED_KEY, "1"); } catch {}
        }

        console.log("[TRANSITION] Preload complete. Success:", success, "Using video:", isVideo);

        // Show/hide appropriate element
        if (isVideo) {
          transitionVideo.style.display = "block";
          transitionImg.style.display = "none";
        } else {
          transitionVideo.style.display = "none";
          transitionImg.style.display = "block";
        }

        // Ensure minimum preload time has passed
        const elapsed = Date.now() - mediaPreloadStartedAt;
        const remaining = Math.max(0, minWait - elapsed);
        if (remaining > 0) {
          console.log("[TRANSITION] Waiting additional", remaining, "ms for buffer time");
          setTimeout(() => resolve(success), remaining);
        } else {
          resolve(success);
        }
      };

      // FIRST: Try video (much more reliable in OBS browser source)
      if (transitionVideo) {
        console.log("[TRANSITION] Trying video sources first...");

        let videoTimeout = setTimeout(() => {
          console.log("[TRANSITION] Video load timeout, falling back to GIF");
          tryGifFallback();
        }, 5000);

        // Check if video can play
        transitionVideo.oncanplaythrough = () => {
          clearTimeout(videoTimeout);
          console.log("[TRANSITION] Video ready to play through!");
          transitionVideo.oncanplaythrough = null;
          transitionVideo.onerror = null;
          finish(true, true);
        };

        transitionVideo.onerror = (e) => {
          clearTimeout(videoTimeout);
          console.log("[TRANSITION] Video error, falling back to GIF:", e);
          transitionVideo.oncanplaythrough = null;
          transitionVideo.onerror = null;
          tryGifFallback();
        };

        // Trigger video load
        transitionVideo.load();

        // Also check if already ready (cached)
        if (transitionVideo.readyState >= 4) {
          clearTimeout(videoTimeout);
          transitionVideo.oncanplaythrough = null;
          transitionVideo.onerror = null;
          console.log("[TRANSITION] Video already cached and ready!");
          finish(true, true);
          return;
        }
      } else {
        tryGifFallback();
      }

      function tryGifFallback() {
        console.log("[TRANSITION] Loading GIF fallback...");

        // Fetch GIF as blob for reliable loading
        fetch(TRANSITION_GIF_BASE, { cache: "force-cache" })
          .then(r => {
            if (!r.ok) throw new Error("HTTP " + r.status);
            return r.blob();
          })
          .then(blob => {
            console.log("[TRANSITION] GIF downloaded, size:", blob.size, "bytes");

            if (blob.size < 1000) throw new Error("Blob too small");

            const blobUrl = URL.createObjectURL(blob);
            transitionGifBlobUrl = blobUrl;

            // Load into image element
            transitionImg.onload = () => {
              console.log("[TRANSITION] GIF loaded:", transitionImg.naturalWidth, "x", transitionImg.naturalHeight);

              // Force decode by drawing to canvas
              try {
                const canvas = document.createElement('canvas');
                canvas.width = transitionImg.naturalWidth;
                canvas.height = transitionImg.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(transitionImg, 0, 0);
                console.log("[TRANSITION] GIF decoded via canvas");
              } catch (e) {}

              finish(true, false);
            };

            transitionImg.onerror = () => {
              console.warn("[TRANSITION] GIF blob load failed, trying direct URL");
              transitionImg.src = TRANSITION_GIF_BASE;
              setTimeout(() => finish(transitionImg.complete, false), 1000);
            };

            transitionImg.src = blobUrl;
          })
          .catch(err => {
            console.warn("[TRANSITION] GIF fetch failed:", err);
            transitionImg.src = TRANSITION_GIF_BASE;
            transitionImg.onload = () => finish(transitionImg.complete, false);
            transitionImg.onerror = () => finish(false, false);
          });
      }

      // Final timeout fallback
      const timeout = gifLoadedThisSession ? 6000 : 12000;
      setTimeout(() => {
        if (!resolved) {
          console.warn("[TRANSITION] Preload timeout after", timeout, "ms");
          // Use whatever we have
          const videoReady = transitionVideo && transitionVideo.readyState >= 2;
          const gifReady = transitionImg.complete && transitionImg.naturalWidth > 0;
          finish(videoReady || gifReady, videoReady);
        }
      }, timeout);
    });
  }

  async function preloadTransitionGifSoft(timeoutMs){
    const t0 = Date.now();
    try { fetch(TRANSITION_GIF_BASE, { cache: "force-cache" }); } catch {}
    while (Date.now() - t0 < timeoutMs) {
      if (transitionImg.complete) break;
      await new Promise(r => setTimeout(r, 30));
    }
  }

  async function warmupTwitchEmbedSoft(timeoutMs){
    const warmUrl = `https://clips.twitch.tv/embed?clip=InvalidClip&parent=${encodeURIComponent(parent)}&autoplay=false&muted=true`;
    return await Promise.race([
      (async () => {
        await new Promise(resolve => {
          const f = document.createElement("iframe");
          f.style.position = "absolute";
          f.style.width = "1px";
          f.style.height = "1px";
          f.style.left = "-9999px";
          f.style.top = "-9999px";
          f.setAttribute("aria-hidden", "true");
          f.setAttribute("tabindex", "-1");
          f.allow = "autoplay; fullscreen";
          f.src = warmUrl;

          let done = false;
          const finish = () => {
            if (done) return;
            done = true;
            try { f.onload = null; } catch {}
            setTimeout(() => { try { f.remove(); } catch {} }, 250);
            resolve();
          };

          f.onload = finish;
          setTimeout(finish, 900);
          document.body.appendChild(f);
        });
      })(),
      new Promise(r => setTimeout(r, timeoutMs))
    ]);
  }

  function showTransition(){
    transitionShownAt = Date.now();

    if (useVideoTransition && transitionVideo) {
      // Video mode - restart and play the video
      transitionVideo.currentTime = 0;
      transitionVideo.play().catch(e => console.warn("[TRANSITION] Video play failed:", e));
    } else {
      // GIF mode - restart the GIF animation
      restartGifHard(TRANSITION_GIF_BASE);
    }

    transition.classList.remove("hide");
  }

  function hideTransitionAfterHold() {
    const elapsed = Date.now() - transitionShownAt;
    const waitToMin = Math.max(0, TRANSITION_MIN_MS - elapsed);
    setTimeout(() => transition.classList.add("hide"), waitToMin);
  }

  function clearTimers() {
    if (advanceTimer) { clearTimeout(advanceTimer); advanceTimer = null; }
    if (transitionTimer) { clearTimeout(transitionTimer); transitionTimer = null; }
    if (prepareTimer) { clearTimeout(prepareTimer); prepareTimer = null; }
    // Note: playlistAdvanceTimer is managed separately in pollPclipOnce to avoid premature cancellation
  }

  function clipSrc(id, autoplay) {
    const ap = autoplay ? "true" : "false";
    const mutedParam = forceMuted ? "true" : "false";
    return `https://clips.twitch.tv/embed?clip=${encodeURIComponent(id)}&parent=${encodeURIComponent(parent)}&autoplay=${ap}&muted=${mutedParam}`;
  }

  // Track what we've set as now playing to avoid duplicate calls
  let lastSetNowPlayingId = null;
  let nowPlayingCallCount = 0;  // Debug counter

  // Rate limiting for now_playing_set to avoid 403 from Porkbun
  const NP_MIN_INTERVAL_MS = 5000;  // Minimum 5 seconds between API calls
  let lastNpCallTime = 0;
  let pendingNpClip = null;
  let npQueueTimer = null;

  async function setNowPlaying(c, forceSet = false) {
    const callNum = ++nowPlayingCallCount;
    try {
      const url = (c && c.url) ? String(c.url) : "";
      const clipId = (c && c.id) ? String(c.id) : "";
      if (!clipId) {
        debugLog("NP#" + callNum + " NO CLIP_ID", "err");
        return false;
      }

      // Skip if we already set this clip (prevents duplicate calls) - unless forced
      if (!forceSet && clipId === lastSetNowPlayingId) {
        debugLog("NP#" + callNum + " skip (same)", "warn");
        return true;
      }

      debugLog("NP#" + callNum + " GET " + clipId.substring(0, 20));
      // Use GET instead of POST - some hosts rate-limit POST more aggressively
      const params = new URLSearchParams({
        login: login,
        url: url,
        clip_id: clipId
      });
      const res = await fetch(`${API_BASE}/now_playing_set.php?` + params.toString(), {
        method: "GET",
        cache: "no-store"
      });
      const text = await res.text();

      if (res.ok && text.trim() === "ok") {
        lastSetNowPlayingId = clipId;
        lastNpCallTime = Date.now();  // Track successful call time
        debugLog("NP#" + callNum + " OK seq updated", "ok");
        return true;
      } else {
        debugLog("NP#" + callNum + " FAIL " + res.status + " " + text.substring(0, 20), "err");
        return false;
      }
    } catch (err) {
      debugLog("NP#" + callNum + " ERR " + String(err).substring(0, 30), "err");
      return false;
    }
  }

  // Rate-limited version that queues calls to avoid 403 rate limiting
  // Only ONE call will be made per NP_MIN_INTERVAL_MS, using the most recent clip
  function setNowPlayingWithRetry(c) {
    const clipId = (c && c.id) ? String(c.id) : "";
    if (!clipId) {
      debugLog("NP: no clip_id!", "err");
      return;
    }

    const now = Date.now();
    const timeSinceLastCall = now - lastNpCallTime;

    // If enough time has passed, make the call immediately
    if (timeSinceLastCall >= NP_MIN_INTERVAL_MS) {
      debugLog("NP: immediate " + clipId.substring(0, 15));
      lastSetNowPlayingId = null;  // Force the call to go through
      setNowPlaying(c, true);
      return;
    }

    // Otherwise, queue it for later (replacing any previous pending)
    pendingNpClip = c;
    const waitMs = NP_MIN_INTERVAL_MS - timeSinceLastCall + 100;  // Add 100ms buffer
    debugLog("NP: queued " + clipId.substring(0, 15) + " wait=" + waitMs + "ms", "warn");

    // Only set timer if not already waiting
    if (!npQueueTimer) {
      npQueueTimer = setTimeout(() => {
        npQueueTimer = null;
        if (pendingNpClip) {
          const queued = pendingNpClip;
          pendingNpClip = null;
          debugLog("NP: dequeue " + (queued.id || "?").substring(0, 15));
          lastSetNowPlayingId = null;
          setNowPlaying(queued, true);
        }
      }, waitMs);
    }
  }

  function computeRevealDelayMs(loadMs) {
    // Reduced delays to minimize transition time covering clips
    // Base delay just enough for iframe to start playing
    let d = 350;
    if (loadMs > 900)  d += 150;
    if (loadMs > 1500) d += 200;
    return Math.min(700, Math.max(300, d));
  }

  // Check if the transition media (video or GIF) is properly loaded
  function isTransitionMediaReady() {
    if (useVideoTransition && transitionVideo) {
      return transitionVideo.readyState >= 2;
    }
    return transitionMediaReady || (transitionImg.complete && transitionImg.naturalWidth > 0);
  }

  // Wait for transition media to be ready
  async function waitForTransitionMedia(maxMs = 3000) {
    const start = Date.now();
    // First check if already fully loaded
    if (transitionMediaReady) {
      console.log("[TRANSITION] Already ready");
      return true;
    }
    // Otherwise wait for it
    while (Date.now() - start < maxMs) {
      if (transitionMediaReady) {
        console.log("[TRANSITION] Ready after", Date.now() - start, "ms");
        return true;
      }
      if (useVideoTransition && transitionVideo && transitionVideo.readyState >= 2) {
        return true;
      }
      if (!useVideoTransition && transitionImg.complete && transitionImg.naturalWidth > 0) {
        await new Promise(r => setTimeout(r, 200));
        return true;
      }
      await new Promise(r => setTimeout(r, 50));
    }
    console.warn("[TRANSITION] Wait timeout after", maxMs, "ms, proceeding anyway");
    return isTransitionMediaReady();
  }

  // Extra time to let clip video buffer after iframe loads (for first clip)
  const FIRST_CLIP_BUFFER_MS = 500;  // Reduced from 1500ms - just enough for video to start

  function revealIframeThenFadeOut(frameToReveal, loadStartedAt) {
    const loadMs = loadStartedAt ? (Date.now() - loadStartedAt) : 0;
    const revealDelay = computeRevealDelayMs(loadMs);

    let extra = IFRAME_SETTLE_PAD_MS;
    if (loadMs > LOAD_SLOW_THRESHOLD_MS) extra += LOAD_SLOW_EXTRA_MS;

    setTimeout(async () => {
      // Hide loading overlay when first clip actually reveals
      if (!firstTransitionShown) {
        // Ensure loading overlay was shown for minimum time (5-10 seconds)
        const loadingElapsed = Date.now() - loadingShownAt;
        const loadingRemaining = Math.max(0, LOADING_OVERLAY_MIN_MS - loadingElapsed);

        // Wait for transition media (video or GIF) to be ready
        await waitForTransitionMedia(2000);

        // If we need more time for loading minimum, wait
        if (loadingRemaining > 0) {
          console.log("[LOADING] Waiting additional", loadingRemaining, "ms for minimum display");
          await new Promise(r => setTimeout(r, loadingRemaining));
        }

        // Extra settle time to ensure clip video is buffered
        await new Promise(r => setTimeout(r, LOADING_EXTRA_SETTLE_MS));

        console.log("[LOADING] Requirements met, hiding overlay");
        hideLoadingOverlay();
        firstTransitionShown = true;

        // For first clip, add extra buffer time before fading out transition
        await new Promise(r => setTimeout(r, FIRST_CLIP_BUFFER_MS));
      }

      frameToReveal.classList.add("live");
      setTimeout(() => hideTransitionAfterHold(), TRANSITION_AFTER_REVEAL_MS + extra);
    }, revealDelay);
  }

  const POP_WEIGHT = 0.55;
  const POP_CAP = 1.8;
  const VOTE_WEIGHT = 0.5;  // Weight per net vote (likes - dislikes)
  const VOTE_CAP = 5;       // Max vote bonus/penalty
  function log10Safe(x){ return Math.log10 ? Math.log10(x) : (Math.log(x) / Math.LN10); }

  function pickNextClip() {
    // In playlist mode, just return the first clip (index 0)
    // The API gives us clips starting from current position
    if (playlistMode && clips.length > 0) {
      console.log("[PLAYLIST] Picking next clip from playlist, index 0 of", clips.length);
      return clips[0];
    }

    // Normal weighted random selection
    const state = loadState();
    state.recent = Array.isArray(state.recent) ? state.recent : [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};
    state.lastGameRecent = Array.isArray(state.lastGameRecent) ? state.lastGameRecent : [];

    const recentSet = new Set(state.recent.slice(-RECENT_BLOCK));
    const recentGames = state.lastGameRecent.slice(-6);

    const candidates = clips.filter(c => !recentSet.has(c.id));
    const usable = candidates.length ? candidates : clips.slice();

    const scored = usable.map(c => {
      const plays = state.playCounts[c.id] || 0;
      const lastAt = state.lastPlayedAt[c.id] || 0;
      const minutesAgo = (nowMs() - lastAt) / 60000;

      let score = 1;
      score += Math.min(5, minutesAgo / 15);
      score += Math.max(0, 3 - plays);
      if (c.game_id && recentGames.includes(c.game_id)) score -= 2;

      const views = Number(c.view_count || 0);
      const pop = log10Safe(views + 1);
      score += Math.min(POP_CAP, pop * POP_WEIGHT);

      // Vote weighting: likes boost, dislikes penalize
      const netVotes = voteScores[c.id] || 0;
      score += Math.max(-VOTE_CAP, Math.min(VOTE_CAP, netVotes * VOTE_WEIGHT));

      return { c, score };
    }).filter(x => x.score > 0.1);

    scored.sort((a,b) => b.score - a.score);
    const top = scored.slice(0, Math.min(25, scored.length));

    const total = top.reduce((s, x) => s + x.score, 0);
    let r = Math.random() * total;
    for (const x of top) { r -= x.score; if (r <= 0) return x.c; }
    return top[0]?.c || clips[0];
  }

  function markPlayed(c) {
    const state = loadState();
    state.recent = Array.isArray(state.recent) ? state.recent : [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};
    state.lastGameRecent = Array.isArray(state.lastGameRecent) ? state.lastGameRecent : [];

    state.recent.push(c.id);
    if (state.recent.length > 2000) state.recent = state.recent.slice(-800);

    state.playCounts[c.id] = (state.playCounts[c.id] || 0) + 1;
    state.lastPlayedAt[c.id] = nowMs();

    if (c.game_id) {
      state.lastGameRecent.push(c.game_id);
      if (state.lastGameRecent.length > 50) state.lastGameRecent = state.lastGameRecent.slice(-20);
    }
    saveState(state);
  }

  function scheduleNext(durationSec) {
    clearTimers();
    const d = Math.max(6, Number(durationSec) || 20);
    console.log("[SCHEDULE] Scheduling next clip in", d, "seconds (duration was:", durationSec, ") playlist:", playlistMode);

    const preAt = Math.max(0, (d * 1000) - TRANSITION_PREROLL_MS);

    prepareTimer = setTimeout(() => {
      console.log("[SCHEDULE] Prepare timer fired");
    }, Math.max(0, preAt - 450));

    transitionTimer = setTimeout(() => {
      console.log("[SCHEDULE] Transition timer fired, showing transition");
      showTransition();
    }, preAt);

    if (fastMode && !playlistMode) {
      const preloadAtMs = Math.min(
        Math.max(1500, Math.floor(d * 0.85) * 1000),
        Math.max(1500, (d - 3) * 1000)
      );
      setTimeout(() => {
        console.log("[SCHEDULE] Preload timer fired");
        preloadNext();
      }, preloadAtMs);
    }

    // Advance shortly after transition shows (reduced from +1 second to +200ms)
    // This minimizes time the transition covers the old clip
    advanceTimer = setTimeout(async () => {
      console.log("[SCHEDULE] Advance timer fired, switching to next clip");

      // In playlist mode, fetch new clip list with advance=1 to move to next playlist clip
      if (playlistMode) {
        console.log("[PLAYLIST] Advancing to next playlist clip...");
        try {
          const advanceUrl = apiUrl + (apiUrl.includes('?') ? '&' : '?') + 'advance=1';
          const r = await fetch(advanceUrl, { cache: "no-store" });
          const d = await r.json();

          if (d.playlist_mode && Array.isArray(d.clips) && d.clips.length > 0) {
            clips = d.clips;
            playlistIndex = d.playlist_index || 0;
            playlistTotal = d.playlist_total || clips.length;
            console.log("[PLAYLIST] Advanced to clip", (playlistIndex + 1), "of", playlistTotal);

            const next = pickNextClip();
            if (next) {
              switchToClip(next);
              return;
            }
          } else {
            // Playlist finished, switch to normal mode
            console.log("[PLAYLIST] Playlist finished, returning to normal mode");
            playlistMode = false;
            clips = Array.isArray(d.clips) ? d.clips : clips;
          }
        } catch (err) {
          console.error("[PLAYLIST] Error advancing:", err);
          playlistMode = false;
        }
      }

      // Normal mode or playlist finished
      if (fastMode) switchFast();
      else switchSmoothBuffered();
    }, (d * 1000) + 200);  // 200ms after transition shows (was +1 second)
  }

  function bindOnloadWithFailsafe(targetFrame, onReady) {
    let done = false;
    try { targetFrame.onload = null; } catch {}

    const t = setTimeout(() => {
      if (done) return;
      done = true;
      try { targetFrame.onload = null; } catch {}
      onReady(true);
    }, IFRAME_LOAD_FAILSAFE_MS);

    targetFrame.onload = () => {
      if (done) return;
      done = true;
      clearTimeout(t);
      onReady(false);
    };
  }

  // Track current clip for verification
  let currentClipId = null;

  let switchCount = 0;  // Debug counter

  function switchToClip(c, playlistData = null) {
    const switchNum = ++switchCount;
    if (!c) {
      debugLog("SW#" + switchNum + " null clip!", "err");
      return;
    }
    debugLog("SW#" + switchNum + " -> " + (c.id || "?").substring(0, 15) + " dur=" + c.duration + (playlistData ? " [PLAYLIST]" : ""));

    // Clear any pending timers when starting a new switch
    clearTimers();
    isSwitching = true;

    // Store clip reference to ensure we use the right one
    const clipToPlay = c;
    currentClipId = c.id;

    if (transition.classList.contains("hide")) {
      console.log("[SWITCH] Showing transition");
      showTransition();
    }

    // IMMEDIATELY kill audio from the old clip by blanking it
    // This prevents audio bleed during the transition
    liveFrame.classList.remove("live");
    try { liveFrame.src = "about:blank"; } catch {}
    console.log("[SWITCH] Old clip audio killed immediately");

    const token = ++nextToken;
    const switchStartedAt = Date.now();

    backFrame.classList.remove("live");

    const loadStartedAt = Date.now();
    bindOnloadWithFailsafe(backFrame, (wasFailsafe) => {
      // Check if we were superseded by another switch
      if (token !== nextToken) {
        debugLog("SW#" + switchNum + " token mismatch, skipped", "warn");
        // Don't set isSwitching=false here, the newer switch will handle it
        return;
      }
      debugLog("SW#" + switchNum + " loaded" + (wasFailsafe ? " (failsafe)" : ""), "ok");

      // liveFrame was already hidden and blanked at switch start (for instant audio kill)
      revealIframeThenFadeOut(backFrame, loadStartedAt);

      const tmp = liveFrame;
      liveFrame = backFrame;
      backFrame = tmp;

      try { backFrame.onload = null; } catch {}

      markPlayed(clipToPlay);

      // Update HUD seq immediately from local data (no server round-trip needed)
      updateHudSeqLocal(clipToPlay);

      // Also try to update server (for !pb command) - may fail due to rate limits
      debugLog("SW#" + switchNum + " calling setNowPlaying");
      setNowPlayingWithRetry(clipToPlay);

      // For playlist clips, DON'T schedule next - the playlist advancement timer handles it
      if (playlistData) {
        debugLog("SW#" + switchNum + " playlist mode - skipping scheduleNext");
      } else {
        // Ensure we have a valid duration
        const dur = (clipToPlay.duration && clipToPlay.duration > 0) ? clipToPlay.duration : 30;
        scheduleNext(dur);
        debugLog("SW#" + switchNum + " next in " + dur + "s");
      }

      isSwitching = false;
      hasStartedPlayback = true;

      // Check for pending forced clip after switch completes
      if (pendingForced && pendingForced.clip) {
        debugLog("SW#" + switchNum + " has pending forced", "warn");
        const forced = pendingForced.clip;
        pendingForced = null;
        setTimeout(() => switchToClip(forced), 100);
      }
    });

    backFrame.src = clipSrc(clipToPlay.id, true);
    console.log("[SWITCH] Iframe src set, token:", token);

    // Safety: reset isSwitching after a reasonable timeout if callback never fires
    setTimeout(() => {
      if (token === nextToken && isSwitching) {
        console.warn("[SWITCH] Safety timeout - callback never fired after", Date.now() - switchStartedAt, "ms");

        // Even on timeout, try to set now playing so the HUD stays in sync
        console.log("[SWITCH] Safety: setting now playing for:", clipToPlay.id);
        setNowPlayingWithRetry(clipToPlay);

        isSwitching = false;
        // Force advancement to recover
        if (clips.length) {
          console.log("[SWITCH] Attempting recovery by switching to next clip");
          switchToClip(pickNextClip());
        }
      }
    }, 15000); // 15 second safety timeout
  }

  function switchSmoothBuffered() {
    console.log("[SMOOTH] switchSmoothBuffered called, clips.length:", clips.length, "isSwitching:", isSwitching);
    if (!clips.length) {
      console.warn("[SMOOTH] No clips available!");
      return;
    }
    const next = pickNextClip();
    console.log("[SMOOTH] Picked next clip:", next?.id, next?.title);
    switchToClip(next);
  }

  function preloadNext() {
    if (!clips.length) return;
    if (nextClip) return;
    // Don't preload if we're currently switching - it will mess up the token
    if (isSwitching) return;

    nextClip = pickNextClip();
    if (!nextClip) return;

    // Clear any existing onload handler before preloading
    // This prevents the preload from triggering the switch callback
    try { backFrame.onload = null; } catch {}

    // Don't increment nextToken here - only switchToClip should do that
    // Just quietly load the clip in the background
    backFrame.src = clipSrc(nextClip.id, false);
  }

  function switchFast() {
    if (!clips.length) return;

    if (!nextClip) preloadNext();
    const c = nextClip || pickNextClip();
    if (!c) return;

    switchToClip(c);
    nextClip = null;
    setTimeout(preloadNext, 900);
  }

  // ===== pclip support, switch by clip_id first =====
  const pclipEnabled = qs.get("pclip") !== "0";
  const pclipPollMs = Math.max(350, Math.min(2500, parseInt(qs.get("pclippoll") || "700", 10)));

  let lastPclipNonce = null;
  let pendingForced = null;

  function clipBySeq(seq){
    const n = parseInt(seq, 10);
    if (!Number.isFinite(n)) return null;
    if (n < 1 || n > clips.length) return null;
    return clips[n - 1];
  }

  function clipById(id){
    const s = (id == null) ? "" : String(id).trim();
    if (!s) return null;
    return clips.find(c => String(c.id) === s) || null;
  }

  async function pollPclipOnce(){
    if (!pclipEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/force_play_get.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const text = await res.text();
      console.log("[PCLIP] Raw response:", text.substring(0, 200));

      if (!text || text === '{}') return;

      let data;
      try {
        data = JSON.parse(text);
      } catch (e) {
        console.error("[PCLIP] JSON parse error:", e);
        return;
      }

      if (!data || Object.keys(data).length === 0) return;

      const nonce = (data.nonce != null) ? String(data.nonce) : null;
      console.log("[PCLIP] Nonce check - received:", nonce, "last:", lastPclipNonce);
      if (!nonce || nonce === lastPclipNonce) return;
      lastPclipNonce = nonce;

      // Ignore stale requests (older than 60 seconds)
      if (data.set_at) {
        const setAtTime = new Date(data.set_at).getTime();
        const ageMs = Date.now() - setAtTime;
        if (ageMs > 60000) {
          console.log("[PCLIP] Ignoring stale request, age:", Math.round(ageMs / 1000), "s");
          return;
        }
      }

      console.log("[PCLIP] Force play command received:", JSON.stringify(data));

      // Try to find in current pool first
      let c = clipById(data.clip_id);
      console.log("[PCLIP] Looking for clip_id:", data.clip_id, "found in pool:", !!c);

      // If not in pool, use full clip data from server response
      if (!c && data.clip) {
        console.log("[PCLIP] Clip not in current pool, using server data:", JSON.stringify(data.clip));
        c = data.clip;
        // Ensure the clip has a duration, default to 30 seconds if missing
        if (!c.duration || c.duration <= 0) {
          console.warn("[PCLIP] Clip missing duration, defaulting to 30s");
          c.duration = 30;
        }
      }

      if (!c) {
        console.warn("[PCLIP] Could not find clip for:", data.clip_id, data.seq);
        console.warn("[PCLIP] data.clip was:", data.clip);
        return;
      }

      console.log("[PCLIP] Final clip object:", JSON.stringify(c));

      // If currently switching, queue this clip for later
      if (isSwitching) {
        console.log("[PCLIP] Switch in progress, queuing forced clip for later");
        pendingForced = { clip: c };
        return;
      }

      // Check if this is a playlist clip
      const isPlaylistClip = !!(data.playlist_id);

      // ALWAYS cancel any pending playlist advance timer when a new clip arrives
      if (playlistAdvanceTimer) {
        clearTimeout(playlistAdvanceTimer);
        playlistAdvanceTimer = null;
        console.log("[PCLIP] Cancelled previous playlist advance timer");
      }

      // For playlist clips, we need to set a flag so switchToClip's callback knows not to schedule normal advancement
      const playlistData = isPlaylistClip ? {
        index: data.playlist_index,
        total: data.playlist_total,
        duration: (c.duration && c.duration > 0) ? c.duration : 30
      } : null;

      // Force the switch immediately
      console.log("[PCLIP] Switching to forced clip:", c.id, "duration:", c.duration, "playlist:", isPlaylistClip);
      switchToClip(c, playlistData);

      // For playlist clips, set up advancement after clip finishes
      if (isPlaylistClip) {
        const clipDuration = playlistData.duration;
        console.log("[PCLIP] Playlist mode: clip", (playlistData.index + 1), "of", playlistData.total, "- will advance after", clipDuration, "seconds");

        // Clear force_play AFTER the clip finishes (for playlist advancement)
        // Store the timer so we can cancel it if a new clip arrives
        playlistAdvanceTimer = setTimeout(() => {
          playlistAdvanceTimer = null; // Clear the reference
          console.log("[PCLIP] Playlist clip ended, showing transition and calling force_play_clear");
          showTransition();
          fetch(`${API_BASE}/force_play_clear.php?login=${encodeURIComponent(login)}`, { cache: "no-store" })
            .then(res => res.json())
            .then(data => {
              console.log("[PCLIP] force_play_clear response:", data);
            })
            .catch(err => console.error("[PCLIP] force_play_clear error:", err));
        }, (clipDuration + 1) * 1000);
      }
    } catch (err) {
      console.error("[PCLIP] Poll error:", err);
    }
  }

  function startPclipPolling(){
    if (!pclipEnabled) return;
    pollPclipOnce();
    setInterval(pollPclipOnce, pclipPollMs);
  }

  async function init() {
    console.log("[INIT] Starting init...");
    showLoadingOverlay();       // show immediately on fresh load
    console.log("[INIT] Loading overlay shown");

    // Start preloading the transition media (video preferred, GIF fallback)
    // This MUST complete before we load any clips
    console.log("[INIT] Starting transition preload (will wait at least", MEDIA_PRELOAD_MIN_MS, "ms)...");
    const mediaPreloadPromise = preloadTransitionMedia();

    // Also do soft warmups in parallel (but don't start clip loading yet)
    preloadTransitionGifSoft(800);
    warmupTwitchEmbedSoft(900);

    // CRITICAL: Wait for media to be fully loaded and buffered before proceeding
    // This ensures the transition plays smoothly on first use
    const mediaReady = await mediaPreloadPromise;
    console.log("[INIT] Media preload complete (ready:", mediaReady, "), elapsed:", Date.now() - mediaPreloadStartedAt, "ms");

    // Extra safety wait to ensure GIF is truly buffered in GPU/memory
    await new Promise(r => setTimeout(r, 500));

    console.log("[INIT] Showing transition");
    showTransition();

    // fetch clip list, but do not block forever
    let data = null;
    console.log("[INIT] Fetching clip list from:", apiUrl);
    try {
      data = await Promise.race([
        fetch(apiUrl, { cache: "no-store" }).then(r => r.json()),
        new Promise((_, rej) => setTimeout(() => rej(new Error("clip list timeout")), 9000))
      ]);
      console.log("[INIT] Clip list fetched, count:", data?.clips?.length || 0);
    } catch (err) {
      console.error("[INIT] FAILED to fetch clip list:", err);
      return;
    }

    clips = Array.isArray(data.clips) ? data.clips : [];
    if (!clips.length) {
      console.error("[INIT] No clips in response, aborting");
      return;
    }

    // Check if we're in playlist mode (from API response)
    if (data.playlist_mode) {
      playlistMode = true;
      playlistIndex = data.playlist_index || 0;
      playlistTotal = data.playlist_total || clips.length;
      playlistName = data.playlist_name || "";
      console.log("[INIT] PLAYLIST MODE - Playing:", playlistName, "clip", (playlistIndex + 1), "of", playlistTotal);
    } else {
      playlistMode = false;
      console.log("[INIT] Normal weighted mode");
    }

    // Fetch vote data for weighting
    try {
      const voteRes = await fetch(`${API_BASE}/votes_export.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const voteData = await voteRes.json();
      if (Array.isArray(voteData.votes)) {
        voteScores = {};
        voteData.votes.forEach(v => {
          voteScores[v.clip_id] = v.net_score || 0;
        });
        console.log("[INIT] Loaded vote data for", Object.keys(voteScores).length, "clips");
      }
    } catch (e) {
      console.log("[INIT] Could not load vote data (ok if no votes yet):", e.message);
    }

    const first = pickNextClip();
    if (!first) {
      console.error("[INIT] pickNextClip returned null, aborting");
      return;
    }
    console.log("[INIT] First clip selected:", first.id, first.title);

    liveFrame.classList.remove("live");

    const loadStartedAt = Date.now();
    console.log("[INIT] Loading first clip into iframe...");
    bindOnloadWithFailsafe(liveFrame, (wasFailsafe) => {
      console.log("[INIT] Iframe loaded (failsafe=%s), revealing...", wasFailsafe);
      revealIframeThenFadeOut(liveFrame, loadStartedAt);
      markPlayed(first);
      updateHudSeqLocal(first);  // Update HUD immediately from local data
      setNowPlayingWithRetry(first);

      try { backFrame.src = "about:blank"; } catch {}

      // Ensure valid duration
      const dur = (first.duration && first.duration > 0) ? first.duration : 30;
      scheduleNext(dur);
      console.log("[INIT] Scheduled next clip in", dur, "seconds (clip duration was:", first.duration, ")");

      if (fastMode) setTimeout(preloadNext, 900);

      hasStartedPlayback = true;
      isSwitching = false;

      if (pendingForced && pendingForced.clip) {
        const c = pendingForced.clip;
        pendingForced = null;
        switchToClip(c);
      }
      console.log("[INIT] Playback started successfully!");
    });

    liveFrame.src = clipSrc(first.id, true);
    console.log("[INIT] Iframe src set to:", liveFrame.src);

    startPclipPolling();
    console.log("[INIT] pclip polling started");

    // Periodic refresh of clip list (every 10 min)
    setInterval(async () => {
      try {
        const r = await fetch(apiUrl, { cache: "no-store" });
        const d = await r.json();
        if (Array.isArray(d.clips) && d.clips.length) clips = d.clips;
      } catch {}
      // Also refresh vote data
      try {
        const vr = await fetch(`${API_BASE}/votes_export.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
        const vd = await vr.json();
        if (Array.isArray(vd.votes)) {
          voteScores = {};
          vd.votes.forEach(v => { voteScores[v.clip_id] = v.net_score || 0; });
        }
      } catch {}
    }, 10 * 60 * 1000);

    // Poll for playlist activation (every 5 seconds when not in playlist mode)
    setInterval(async () => {
      // Only check when NOT already in playlist mode
      if (playlistMode) return;

      try {
        const r = await fetch(apiUrl, { cache: "no-store" });
        const d = await r.json();

        // If API returns playlist_mode, switch to it immediately
        if (d.playlist_mode && Array.isArray(d.clips) && d.clips.length > 0) {
          console.log("[PLAYLIST-POLL] Playlist detected! Switching to playlist mode...");
          playlistMode = true;
          playlistIndex = d.playlist_index || 0;
          playlistTotal = d.playlist_total || d.clips.length;
          playlistName = d.playlist_name || "";
          clips = d.clips;

          // Cancel current advance timer and switch to first playlist clip
          if (advanceTimer) {
            clearTimeout(advanceTimer);
            advanceTimer = null;
          }

          const next = pickNextClip();
          if (next) {
            console.log("[PLAYLIST-POLL] Starting playlist:", playlistName, "- first clip:", next.title);
            switchToClip(next);
          }
        }
      } catch (err) {
        // Silent fail - don't spam console
      }
    }, 5000);

    // Poll for skip requests (every 1 second)
    setInterval(async () => {
      if (!hasStartedPlayback) return;
      if (isSwitching) return;

      try {
        const r = await fetch(`${API_BASE}/skip_check.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
        const d = await r.json();

        if (d.skip) {
          console.log("[SKIP] Skip requested! Switching to next clip...");

          // Cancel current advance timer
          clearTimers();

          // In playlist mode, advance to next playlist clip
          if (playlistMode) {
            console.log("[SKIP] Playlist mode - advancing to next clip");
            try {
              const advanceUrl = apiUrl + (apiUrl.includes('?') ? '&' : '?') + 'advance=1';
              const ar = await fetch(advanceUrl, { cache: "no-store" });
              const ad = await ar.json();

              if (ad.playlist_mode && Array.isArray(ad.clips) && ad.clips.length > 0) {
                clips = ad.clips;
                playlistIndex = ad.playlist_index || 0;
                playlistTotal = ad.playlist_total || clips.length;
                const next = pickNextClip();
                if (next) switchToClip(next);
              } else {
                // Playlist finished
                playlistMode = false;
                clips = Array.isArray(ad.clips) ? ad.clips : clips;
                switchToClip(pickNextClip());
              }
            } catch (err) {
              console.error("[SKIP] Error advancing playlist:", err);
              playlistMode = false;
              switchToClip(pickNextClip());
            }
          } else {
            // Normal mode - just pick next clip
            switchToClip(pickNextClip());
          }
        }
      } catch (err) {
        // Silent fail
      }
    }, 1000);
  }

  init();
})();
</script>
</body>
</html>
