<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FloppyJimmie MP4 Reel</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }

    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
    }

    #loadingOverlay {
      position: absolute;
      inset: 0;
      z-index: 99999;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 1;
      transition: opacity 400ms ease-out;
    }
    #loadingOverlay.hide { opacity: 0; pointer-events: none; }
    #loadingOverlay .content { text-align: center; color: #fff; font: 600 24px/1.4 system-ui, sans-serif; }
    #loadingOverlay .spinner {
      width: 48px; height: 48px; border-radius: 50%;
      border: 4px solid rgba(255,255,255,0.2); border-top-color: #fff;
      margin: 0 auto 20px; animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #voteHud {
      position: absolute;
      right: 24px;
      top: 24px;
      z-index: 11000;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      padding: 18px 24px;
      border-radius: 16px;
      background: rgba(0,0,0,0.25);
      border: 2px solid rgba(255,255,255,0.15);
      color: #fff;
      font: 18px/1.3 system-ui, sans-serif;
      backdrop-filter: blur(12px);
      opacity: 0;
      transform: translateX(6px);
      transition: opacity 180ms, transform 180ms;
      box-shadow: 0 4px 24px rgba(0,0,0,0.6);
      max-width: 550px;
      text-align: center;
      pointer-events: none;
    }
    #voteHud.show { opacity: 1; transform: translateX(0); }
    #voteHud .clip-info { display: flex; flex-direction: column; gap: 6px; width: 100%; align-items: center; }
    #voteHud .seq { font-weight: 800; font-size: 24px; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.7); }
    #voteHud .clip-date-hud { font-weight: 600; font-size: 18px; color: #a0a0ff; margin-left: 10px; }
    #voteHud .clip-title { font-weight: 600; font-size: 18px; color: #f0f0f0; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    #voteHud .clip-meta { font-size: 17px; font-weight: 600; color: #e8e8e8; display: flex; gap: 14px; justify-content: center; flex-wrap: wrap; }
    #voteHud .meta-duration { color: #fbbf24; }
    #voteHud .meta-category { color: #22d3ee; }
    #voteHud .meta-clipper-label { color: #a0a0a0; }
    #voteHud .meta-clipper-name { color: #c084fc; }
    #voteHud .vote-section { display: flex; gap: 14px; align-items: center; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); width: 100%; justify-content: center; }
    #voteHud .pill { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; border-radius: 999px; font-weight: 700; font-size: 18px; }
    #voteHud .pill.up { background: rgba(34,197,94,0.2); border: 2px solid rgba(34,197,94,0.6); color: #4ade80; }
    #voteHud .pill.down { background: rgba(239,68,68,0.2); border: 2px solid rgba(239,68,68,0.6); color: #f87171; }
    #voteHud .hints { display: flex; flex-direction: column; gap: 3px; font-size: 16px; font-weight: 700; }
    #voteHud .hint-like { color: #4ade80; }
    #voteHud .hint-dislike { color: #f87171; }

    #debugOverlay {
      position: absolute;
      right: 10px;
      bottom: 10px;
      z-index: 999999;
      background: rgba(0,0,0,0.95);
      color: #0f0;
      font: 12px/1.4 monospace;
      padding: 10px 12px;
      border-radius: 6px;
      border: 2px solid #0f0;
      max-width: 450px;
      max-height: 250px;
      overflow: hidden;
      display: none;
      pointer-events: none;
    }
    #debugOverlay.show { display: block; }
    #debugOverlay .ok { color: #4ade80; }
    #debugOverlay .err { color: #f87171; }
    #debugOverlay .warn { color: #fbbf24; }
  </style>
</head>
<body>
  <video id="player" autoplay playsinline></video>

  <div id="voteHud">
    <div class="clip-info">
      <div style="display:flex;align-items:baseline;justify-content:center;gap:0;">
        <span class="seq" id="voteSeq">Clip</span>
        <span class="clip-date-hud" id="clipDateHud"></span>
      </div>
      <span class="clip-title" id="clipTitle"></span>
      <span class="clip-meta" id="clipMeta"></span>
    </div>
    <div class="vote-section">
      <span class="pill up" id="voteUp">üëç 0</span>
      <span class="pill down" id="voteDown">üëé 0</span>
      <div class="hints">
        <span class="hint-like" id="hintLike">!like #</span>
        <span class="hint-dislike" id="hintDislike">!dislike #</span>
      </div>
    </div>
  </div>

  <div id="loadingOverlay">
    <div class="content">
      <div class="spinner"></div>
      <div class="text">Loading Clips...</div>
    </div>
  </div>

  <div id="debugOverlay"></div>

<script>
(() => {
  const qs = new URLSearchParams(location.search);

  const login  = (qs.get("login") || "floppyjimmie").toLowerCase();
  const days   = parseInt(qs.get("days") || "180", 10);
  const pool   = parseInt(qs.get("pool") || "400", 10);
  const forceMuted = qs.get("muted") === "1";

  const API_BASE = "https://clipsystem-production.up.railway.app";
  const apiUrl = `${API_BASE}/twitch_reel_api.php?login=${encodeURIComponent(login)}&days=${days}&pool=${pool}`;

  // Twitch GQL for MP4 URLs
  const GQL_URL = "https://gql.twitch.tv/gql";
  const CLIENT_ID = "kimne78kx3ncx6brgo4mv6wki5h1ko";
  const QUERY_HASH = "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11";

  const RECENT_BLOCK = Math.max(10, Math.floor(pool * 0.20));
  const storageKey = `away_reel_state_${login}`;

  const player = document.getElementById("player");
  const loadingOverlay = document.getElementById("loadingOverlay");
  const voteHud = document.getElementById("voteHud");
  const voteSeq = document.getElementById("voteSeq");
  const clipDateHud = document.getElementById("clipDateHud");
  const clipTitle = document.getElementById("clipTitle");
  const clipMeta = document.getElementById("clipMeta");
  const voteUp = document.getElementById("voteUp");
  const voteDown = document.getElementById("voteDown");
  const hintLike = document.getElementById("hintLike");
  const hintDislike = document.getElementById("hintDislike");

  player.muted = forceMuted;

  // Debug
  const debugEnabled = qs.get("debug") === "1";
  const debugOverlay = document.getElementById("debugOverlay");
  const debugLines = [];

  function debugLog(msg, type = "info") {
    if (!debugEnabled) return;
    const time = new Date().toLocaleTimeString("en-US", { hour12: false });
    debugLines.push({ time, msg, type });
    if (debugLines.length > 12) debugLines.shift();
    debugOverlay.classList.add("show");
    debugOverlay.innerHTML = debugLines.map(l => `<div class="${l.type}">${l.time} ${l.msg}</div>`).join("");
  }

  // State
  let clips = [];
  let voteScores = {};
  let currentClip = null;
  let failedClips = new Set();
  let isSwitching = false;
  let advanceTimer = null;

  // HUD
  const hudEnabled = qs.get("hud") !== "0";
  const hudPollMs = parseInt(qs.get("hudpoll") || "900", 10);

  function formatDuration(s) {
    if (!s || s <= 0) return "";
    s = Math.round(s);
    return s < 60 ? `${s}s` : `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
  }

  function formatDate(d) {
    if (!d) return "";
    try {
      return new Date(d).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
    } catch { return ""; }
  }

  function updateHud(clip) {
    if (!hudEnabled || !clip) return;
    const seq = clip.seq || 0;
    voteSeq.textContent = `Clip #${seq}`;
    hintLike.textContent = `!like ${seq}`;
    hintDislike.textContent = `!dislike ${seq}`;
    clipDateHud.textContent = formatDate(clip.created_at) ? `‚Ä¢ ${formatDate(clip.created_at)}` : "";
    clipTitle.textContent = clip.title || "";

    const meta = [];
    const dur = formatDuration(clip.duration);
    if (dur) meta.push(`<span class="meta-duration">${dur}</span>`);
    if (clip.game_name) meta.push(`<span class="meta-category">${clip.game_name}</span>`);
    if (clip.creator_name) meta.push(`<span><span class="meta-clipper-label">Clipped by</span> <span class="meta-clipper-name">${clip.creator_name}</span></span>`);
    clipMeta.innerHTML = meta.join("");
    voteHud.classList.add("show");
  }

  async function pollVotes() {
    if (!hudEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/vote_status.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      voteUp.textContent = `üëç ${data?.up || 0}`;
      voteDown.textContent = `üëé ${data?.down || 0}`;
    } catch {}
  }

  // Persistence
  function loadState() { try { return JSON.parse(localStorage.getItem(storageKey) || "{}"); } catch { return {}; } }
  function saveState(s) { localStorage.setItem(storageKey, JSON.stringify(s)); }

  // GQL: Get MP4 URL with timeout
  async function getMp4Url(clipId) {
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 8000); // 8 second timeout

      const res = await fetch(GQL_URL, {
        method: "POST",
        headers: { "Client-ID": CLIENT_ID, "Content-Type": "application/json" },
        body: JSON.stringify({
          operationName: "VideoAccessToken_Clip",
          variables: { slug: clipId },
          extensions: { persistedQuery: { version: 1, sha256Hash: QUERY_HASH } }
        }),
        signal: controller.signal
      });
      clearTimeout(timeout);

      if (!res.ok) return null;
      const data = await res.json();
      const clip = data?.data?.clip;
      if (!clip) return null;

      const token = clip.playbackAccessToken?.value;
      const sig = clip.playbackAccessToken?.signature;
      const qualities = clip.videoQualities || [];
      if (!token || !sig || !qualities.length) return null;

      const best = qualities.sort((a,b) => (parseInt(b.quality)||0) - (parseInt(a.quality)||0))[0];
      const sep = best.sourceURL.includes("?") ? "&" : "?";
      return `${best.sourceURL}${sep}sig=${encodeURIComponent(sig)}&token=${encodeURIComponent(token)}`;
    } catch (e) {
      debugLog("GQL err: " + e.message, "err");
      return null;
    }
  }

  // Weighted selection
  function pickNextClip() {
    const state = loadState();
    state.recent = Array.isArray(state.recent) ? state.recent : [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};

    const recentSet = new Set(state.recent.slice(-RECENT_BLOCK));
    // Also exclude failed clips
    const candidates = clips.filter(c => !recentSet.has(c.id) && !failedClips.has(c.id));
    const usable = candidates.length ? candidates : clips.filter(c => !failedClips.has(c.id));

    if (!usable.length) {
      // All clips failed or blocked, reset failed set
      failedClips.clear();
      return clips[Math.floor(Math.random() * clips.length)];
    }

    const scored = usable.map(c => {
      const plays = state.playCounts[c.id] || 0;
      const lastAt = state.lastPlayedAt[c.id] || 0;
      const minutesAgo = (Date.now() - lastAt) / 60000;

      let score = 1;
      score += Math.min(5, minutesAgo / 15);
      score += Math.max(0, 3 - plays);

      const views = Number(c.view_count || 0);
      score += Math.min(1.8, Math.log10(views + 1) * 0.55);

      const netVotes = voteScores[c.id] || 0;
      score += Math.max(-5, Math.min(5, netVotes * 0.5));

      return { c, score };
    }).filter(x => x.score > 0.1);

    scored.sort((a,b) => b.score - a.score);
    const top = scored.slice(0, 25);

    const total = top.reduce((s,x) => s + x.score, 0);
    let r = Math.random() * total;
    for (const x of top) { r -= x.score; if (r <= 0) return x.c; }
    return top[0]?.c || usable[0];
  }

  function markPlayed(c) {
    const state = loadState();
    state.recent = state.recent || [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};

    state.recent.push(c.id);
    if (state.recent.length > 2000) state.recent = state.recent.slice(-800);
    state.playCounts[c.id] = (state.playCounts[c.id] || 0) + 1;
    state.lastPlayedAt[c.id] = Date.now();
    saveState(state);
  }

  // Now playing
  async function setNowPlaying(c) {
    if (!c?.id) return;
    try {
      await fetch(`${API_BASE}/now_playing.php`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ login, clip_id: c.id, title: c.title, duration: c.duration, view_count: c.view_count })
      });
    } catch {}
  }

  // Play clip with robust timeout handling
  let loadTimeout = null;
  let stallTimeout = null;

  function clearVideoTimeouts() {
    if (loadTimeout) { clearTimeout(loadTimeout); loadTimeout = null; }
    if (stallTimeout) { clearTimeout(stallTimeout); stallTimeout = null; }
  }

  function resetStallTimer() {
    if (stallTimeout) clearTimeout(stallTimeout);
    // If video hasn't progressed in 8 seconds, skip
    stallTimeout = setTimeout(() => {
      debugLog("Video stalled, skipping", "warn");
      failedClips.add(currentClip?.id);
      isSwitching = false;
      playNext();
    }, 8000);
  }

  async function playClip(c) {
    if (!c) return;
    isSwitching = true;
    currentClip = c;
    clearVideoTimeouts();
    debugLog(`Loading: ${c.id.substring(0,20)}...`);

    const mp4Url = await getMp4Url(c.id);
    if (!mp4Url) {
      debugLog(`No MP4 for ${c.id}`, "err");
      failedClips.add(c.id);
      isSwitching = false;
      playNext();
      return;
    }

    // Set load timeout - if video doesn't start within 12s, skip
    loadTimeout = setTimeout(() => {
      debugLog(`Load timeout for ${c.id.substring(0,15)}`, "err");
      failedClips.add(c.id);
      player.src = ""; // Clear source
      isSwitching = false;
      playNext();
    }, 12000);

    // Clear old handlers
    player.oncanplay = null;
    player.onerror = null;
    player.onplaying = null;
    player.ontimeupdate = null;
    player.onstalled = null;
    player.onwaiting = null;

    player.src = mp4Url;
    player.load();

    player.oncanplay = () => {
      player.oncanplay = null; // Only fire once
      clearTimeout(loadTimeout);
      loadTimeout = null;

      player.play().then(() => {
        debugLog(`Playing: ${c.title?.substring(0,30) || c.id}`, "ok");
        loadingOverlay.classList.add("hide");
        updateHud(c);
        markPlayed(c);
        setNowPlaying(c);
        scheduleNext(c.duration || 30);
        isSwitching = false;
        resetStallTimer();
      }).catch(err => {
        debugLog(`Play err: ${err.message}`, "err");
        clearVideoTimeouts();
        failedClips.add(c.id);
        isSwitching = false;
        playNext();
      });
    };

    // Reset stall timer on progress
    player.ontimeupdate = () => {
      resetStallTimer();
    };

    // Handle stall/waiting events
    player.onstalled = () => {
      debugLog("Video stalling...", "warn");
    };

    player.onwaiting = () => {
      debugLog("Video buffering...", "warn");
    };

    player.onerror = () => {
      debugLog(`Video error, skipping`, "err");
      clearVideoTimeouts();
      failedClips.add(c.id);
      isSwitching = false;
      playNext();
    };
  }

  function playNext() {
    if (isSwitching) return;
    const next = pickNextClip();
    if (next) playClip(next);
  }

  function scheduleNext(duration) {
    if (advanceTimer) clearTimeout(advanceTimer);
    const d = Math.max(6, duration || 20);
    debugLog(`Next in ${d}s`);
    advanceTimer = setTimeout(() => {
      debugLog("Advancing...");
      playNext();
    }, d * 1000);
  }

  // Video ended event (backup)
  player.onended = () => {
    debugLog("Video ended");
    clearVideoTimeouts();
    if (advanceTimer) clearTimeout(advanceTimer);
    playNext();
  };

  // Force play polling - persist nonce to avoid replaying on page reload
  const pclipEnabled = qs.get("pclip") !== "0";
  const pclipNonceKey = `pclip_nonce_${login}`;
  let lastPclipNonce = localStorage.getItem(pclipNonceKey) || null;

  // Clear force play on server after we start playing it
  async function clearForcePlay() {
    try {
      await fetch(`${API_BASE}/force_play_clear.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      debugLog("Force play cleared", "ok");
    } catch {}
  }

  async function pollForcePlay() {
    if (!pclipEnabled) return;

    try {
      const res = await fetch(`${API_BASE}/force_play_get.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (!data || !data.nonce || data.nonce === lastPclipNonce) return;

      // Ignore stale commands (older than 30 seconds)
      if (data.set_at) {
        const age = Date.now() - new Date(data.set_at).getTime();
        if (age > 30000) {
          // Mark as seen and clear from server
          lastPclipNonce = data.nonce;
          localStorage.setItem(pclipNonceKey, data.nonce);
          clearForcePlay();
          return;
        }
      }

      lastPclipNonce = data.nonce;
      localStorage.setItem(pclipNonceKey, data.nonce);

      let c = clips.find(x => x.id === data.clip_id);
      if (!c && data.clip) c = data.clip;
      if (!c) return;

      debugLog(`Force play: ${c.id.substring(0,15)}`, "warn");
      clearVideoTimeouts();
      if (advanceTimer) clearTimeout(advanceTimer);

      // Clear the force play from server immediately so it doesn't replay
      clearForcePlay();

      playClip(c);
    } catch {}
  }

  // Skip polling
  async function pollSkip() {
    if (isSwitching) return;
    try {
      const res = await fetch(`${API_BASE}/skip_check.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (data?.skip) {
        debugLog("Skip requested", "warn");
        clearVideoTimeouts();
        if (advanceTimer) clearTimeout(advanceTimer);
        playNext();
      }
    } catch {}
  }

  // Init
  async function init() {
    debugLog("Init starting...");

    // Fetch clips
    try {
      const res = await fetch(apiUrl, { cache: "no-store" });
      const data = await res.json();
      clips = Array.isArray(data.clips) ? data.clips : [];
      debugLog(`Loaded ${clips.length} clips`, "ok");
    } catch (e) {
      debugLog("Fetch failed: " + e.message, "err");
      return;
    }

    if (!clips.length) {
      debugLog("No clips!", "err");
      return;
    }

    // Fetch votes
    try {
      const res = await fetch(`${API_BASE}/votes_export.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (Array.isArray(data.votes)) {
        data.votes.forEach(v => { voteScores[v.clip_id] = v.net_score || 0; });
        debugLog(`Loaded ${Object.keys(voteScores).length} votes`);
      }
    } catch {}

    // Start playback
    const first = pickNextClip();
    if (first) playClip(first);

    // Polling
    if (hudEnabled) {
      pollVotes();
      setInterval(pollVotes, hudPollMs);
    }
    setInterval(pollForcePlay, 700);
    setInterval(pollSkip, 1000);

    // Refresh clips periodically
    setInterval(async () => {
      try {
        const res = await fetch(apiUrl, { cache: "no-store" });
        const data = await res.json();
        if (Array.isArray(data.clips) && data.clips.length) clips = data.clips;
      } catch {}
    }, 10 * 60 * 1000);
  }

  init();
})();
</script>
</body>
</html>
