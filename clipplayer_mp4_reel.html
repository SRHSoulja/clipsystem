<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clip Reel</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }

    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
    }

    #loadingOverlay {
      position: absolute;
      inset: 0;
      z-index: 99999;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 1;
      transition: opacity 400ms ease-out;
    }
    #loadingOverlay.hide { opacity: 0; pointer-events: none; }
    #loadingOverlay .content { text-align: center; color: #fff; font: 600 24px/1.4 system-ui, sans-serif; }
    #loadingOverlay .spinner {
      width: 48px; height: 48px; border-radius: 50%;
      border: 4px solid rgba(255,255,255,0.2); border-top-color: #fff;
      margin: 0 auto 20px; animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #voteHud {
      position: absolute;
      right: 24px;
      top: 24px;
      bottom: auto;
      left: auto;
      z-index: 11000;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      padding: 18px 24px;
      border-radius: 16px;
      background: rgba(0,0,0,0.25);
      border: 2px solid rgba(255,255,255,0.15);
      color: #fff;
      font: 18px/1.3 system-ui, sans-serif;
      backdrop-filter: blur(12px);
      opacity: 0;
      transform: translateX(6px);
      transition: opacity 180ms, transform 180ms, top 300ms ease, bottom 300ms ease, left 300ms ease, right 300ms ease;
      box-shadow: 0 4px 24px rgba(0,0,0,0.6);
      max-width: 550px;
      text-align: center;
      pointer-events: none;
    }
    #voteHud.show { opacity: 1; transform: translateX(0); }
    /* HUD positions */
    #voteHud.pos-tr { top: 24px !important; right: 24px !important; bottom: auto !important; left: auto !important; transform: translateX(6px); }
    #voteHud.pos-tr.show { transform: translateX(0); }
    #voteHud.pos-tl { top: 24px !important; left: 24px !important; bottom: auto !important; right: auto !important; transform: translateX(-6px); }
    #voteHud.pos-tl.show { transform: translateX(0); }
    #voteHud.pos-br { bottom: 24px !important; right: 24px !important; top: auto !important; left: auto !important; transform: translateX(6px); }
    #voteHud.pos-br.show { transform: translateX(0); }
    #voteHud.pos-bl { bottom: 24px !important; left: 24px !important; top: auto !important; right: auto !important; transform: translateX(-6px); }
    #voteHud.pos-bl.show { transform: translateX(0); }
    #voteHud .clip-info { display: flex; flex-direction: column; gap: 6px; width: 100%; align-items: center; }
    #voteHud .seq { font-weight: 800; font-size: 24px; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.7); }
    #voteHud .clip-date-hud { font-weight: 600; font-size: 18px; color: #a0a0ff; margin-left: 10px; }
    #voteHud .clip-title { font-weight: 600; font-size: 18px; color: #f0f0f0; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    #voteHud .clip-meta { font-size: 17px; font-weight: 600; color: #e8e8e8; display: flex; gap: 14px; justify-content: center; flex-wrap: wrap; }
    #voteHud .meta-duration { color: #fbbf24; }
    #voteHud .meta-category { color: #22d3ee; }
    #voteHud .meta-clipper-label { color: #a0a0a0; }
    #voteHud .meta-clipper-name { color: #c084fc; }
    #voteHud .vote-section { display: flex; gap: 14px; align-items: center; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); width: 100%; justify-content: center; }
    #voteHud .pill { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; border-radius: 999px; font-weight: 700; font-size: 18px; cursor: pointer; pointer-events: auto; border: 2px solid; background: none; font-family: inherit; outline: none; -webkit-tap-highlight-color: transparent; transition: all 200ms; }
    #voteHud .pill:hover { transform: scale(1.08); }
    #voteHud .pill:active { transform: scale(0.95); }
    #voteHud .pill:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    #voteHud .pill.up { background: rgba(34,197,94,0.2); border-color: rgba(34,197,94,0.6); color: #4ade80; }
    #voteHud .pill.up.voted { background: rgba(34,197,94,0.5); border-color: #4ade80; color: #fff; box-shadow: 0 0 12px rgba(34,197,94,0.4); }
    #voteHud .pill.down { background: rgba(239,68,68,0.2); border-color: rgba(239,68,68,0.6); color: #f87171; }
    #voteHud .pill.down.voted { background: rgba(239,68,68,0.5); border-color: #f87171; color: #fff; box-shadow: 0 0 12px rgba(239,68,68,0.4); }
    #voteHud .login-prompt { font-size: 12px; padding-top: 4px; pointer-events: auto; }
    #voteHud .login-prompt a { color: #a78bfa; text-decoration: none; pointer-events: auto; }
    #voteHud .login-prompt a:hover { color: #c4b5fd; text-decoration: underline; }
    #voteHud .hints { display: flex; flex-direction: column; gap: 3px; font-size: 16px; font-weight: 700; }
    #voteHud .hint-like { color: #4ade80; }
    #voteHud .hint-dislike { color: #f87171; }

    #debugOverlay {
      position: absolute;
      right: 10px;
      bottom: 10px;
      z-index: 999999;
      background: rgba(0,0,0,0.95);
      color: #0f0;
      font: 12px/1.4 monospace;
      padding: 10px 12px;
      border-radius: 6px;
      border: 2px solid #0f0;
      max-width: 450px;
      max-height: 250px;
      overflow: hidden;
      display: none;
      pointer-events: none;
    }
    #debugOverlay.show { display: block; }
    #debugOverlay .ok { color: #4ade80; }
    #debugOverlay .err { color: #f87171; }
    #debugOverlay .warn { color: #fbbf24; }

    /* Top Clips Overlay */
    #topClipsOverlay {
      position: absolute;
      right: 24px;
      bottom: 24px;
      top: auto;
      left: auto;
      z-index: 12000;
      background: rgba(0,0,0,0.85);
      border: 2px solid rgba(255,215,0,0.6);
      border-radius: 16px;
      padding: 16px 20px;
      color: #fff;
      font: 16px/1.4 system-ui, sans-serif;
      backdrop-filter: blur(12px);
      box-shadow: 0 4px 24px rgba(0,0,0,0.8);
      min-width: 280px;
      max-width: 400px;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 300ms ease-out, transform 300ms ease-out, top 300ms ease, bottom 300ms ease, left 300ms ease, right 300ms ease;
      pointer-events: none;
    }
    #topClipsOverlay.show {
      opacity: 1;
      transform: translateY(0);
    }
    /* Top Clips Overlay positions */
    #topClipsOverlay.pos-tr { top: 24px !important; right: 24px !important; bottom: auto !important; left: auto !important; }
    #topClipsOverlay.pos-tl { top: 24px !important; left: 24px !important; bottom: auto !important; right: auto !important; }
    #topClipsOverlay.pos-br { bottom: 24px !important; right: 24px !important; top: auto !important; left: auto !important; }
    #topClipsOverlay.pos-bl { bottom: 24px !important; left: 24px !important; top: auto !important; right: auto !important; }
    #topClipsOverlay .header {
      font-size: 20px;
      font-weight: 800;
      color: #ffd700;
      margin-bottom: 12px;
      text-align: center;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    #topClipsOverlay .clip-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    #topClipsOverlay .clip-row:last-child {
      border-bottom: none;
    }
    #topClipsOverlay .rank {
      font-size: 18px;
      font-weight: 800;
      color: #ffd700;
      min-width: 28px;
      text-align: center;
    }
    #topClipsOverlay .rank.gold { color: #ffd700; }
    #topClipsOverlay .rank.silver { color: #c0c0c0; }
    #topClipsOverlay .rank.bronze { color: #cd7f32; }
    #topClipsOverlay .clip-info {
      flex: 1;
      overflow: hidden;
    }
    #topClipsOverlay .clip-seq {
      font-weight: 700;
      color: #a0a0ff;
      margin-right: 6px;
    }
    #topClipsOverlay .clip-title {
      color: #f0f0f0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #topClipsOverlay .clip-votes {
      display: flex;
      gap: 8px;
      font-weight: 700;
      font-size: 14px;
    }
    #topClipsOverlay .votes-up { color: #4ade80; }
    #topClipsOverlay .votes-down { color: #f87171; }
    #topClipsOverlay .net-score { color: #fbbf24; font-weight: 800; }

    /* Volume control */
    #volumeControl {
      position: absolute;
      right: 24px;
      bottom: 24px;
      z-index: 11000;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      border-radius: 999px;
      background: rgba(0,0,0,0.7);
      border: 2px solid rgba(255,255,255,0.2);
      backdrop-filter: blur(12px);
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 300ms, transform 300ms;
      pointer-events: auto;
    }
    #volumeControl.show { opacity: 1; transform: translateY(0); }
    #volumeBtn {
      background: none;
      border: none;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #volumeSlider {
      width: 100px;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255,255,255,0.3);
      border-radius: 3px;
      cursor: pointer;
    }
    #volumeSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }
    #volumeSlider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }
    /* Banner Overlay */
    #bannerOverlay {
      position: absolute; z-index: 13000; left: 0; right: 0;
      display: none; align-items: center; justify-content: center;
      padding: 12px 24px; pointer-events: none; font-weight: 600;
      transition: background 0.3s, color 0.3s;
    }
    #bannerOverlay.pos-top { top: 0; bottom: auto; }
    #bannerOverlay.pos-center { top: 50%; bottom: auto; }
    #bannerOverlay.pos-bottom { bottom: 0; top: auto; }
    @keyframes bannerPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    #bannerOverlay { overflow: hidden; }
    @keyframes bannerScroll {
      0% { transform: translateX(calc(50vw + 50%)); }
      100% { transform: translateX(calc(-50vw - 50%)); }
    }
  </style>
</head>
<body>
  <video id="player" playsinline preload="auto"></video>

  <div id="voteHud">
    <div class="clip-info">
      <div style="display:flex;align-items:baseline;justify-content:center;gap:0;">
        <span class="seq" id="voteSeq">Clip</span>
        <span class="clip-date-hud" id="clipDateHud"></span>
      </div>
      <span class="clip-title" id="clipTitle"></span>
      <span class="clip-meta" id="clipMeta"></span>
    </div>
    <div class="vote-section">
      <button class="pill up" id="voteUp" type="button">üëç 0</button>
      <button class="pill down" id="voteDown" type="button">üëé 0</button>
      <div class="hints">
        <span class="hint-like" id="hintLike">!like #</span>
        <span class="hint-dislike" id="hintDislike">!dislike #</span>
      </div>
    </div>
    <div class="login-prompt" id="loginPrompt" style="display:none;">
      <a id="loginLink" href="#">Login with Twitch to vote</a>
    </div>
  </div>

  <div id="loadingOverlay">
    <div class="content">
      <div class="spinner"></div>
      <div class="text">Loading Clips...</div>
    </div>
  </div>

  <div id="debugOverlay"></div>

  <div id="topClipsOverlay">
    <div class="header">Top Clips</div>
    <div id="topClipsList"></div>
  </div>

  <div id="volumeControl">
    <button id="volumeBtn">üîä</button>
    <input type="range" id="volumeSlider" min="0" max="100" value="100">
  </div>

  <div id="bannerOverlay"><span id="bannerText"></span></div>

<script>
// Block all navigation ‚Äî this is an OBS browser source, not an interactive page
document.addEventListener('click', e => {
  const a = e.target.closest('a');
  if (a && a.href && a.href !== '#' && !a.href.startsWith('javascript:')) {
    e.preventDefault();
  }
});
window.addEventListener('beforeunload', e => { e.preventDefault(); });

(() => {
  const qs = new URLSearchParams(location.search);

  const login  = (qs.get("login") || "floppyjimmie").toLowerCase();
  document.title = login + " Clip Reel";
  const days   = parseInt(qs.get("days") || "0", 10);  // 0 = all time
  const pool   = parseInt(qs.get("pool") || "300", 10);  // ~2 hours of clips, refreshed every 10 min
  const forceMuted = qs.get("muted") === "1";
  const instance = qs.get("instance") || "";  // Optional instance ID for multi-player isolation

  const API_BASE = "https://clips.gmgnrepeat.com";
  const apiUrl = `${API_BASE}/twitch_reel_api.php?login=${encodeURIComponent(login)}&days=${days}&pool=${pool}`;

  // Twitch GQL for MP4 URLs
  const GQL_URL = "https://gql.twitch.tv/gql";
  const CLIENT_ID = "kimne78kx3ncx6brgo4mv6wki5h1ko";
  const QUERY_HASH = "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11";

  const RECENT_BLOCK = Math.max(10, Math.floor(pool * 0.20));
  const storageKey = `away_reel_state_${login}`;

  const player = document.getElementById("player");
  const loadingOverlay = document.getElementById("loadingOverlay");
  const voteHud = document.getElementById("voteHud");
  const voteSeq = document.getElementById("voteSeq");
  const clipDateHud = document.getElementById("clipDateHud");
  const clipTitle = document.getElementById("clipTitle");
  const clipMeta = document.getElementById("clipMeta");
  const voteUp = document.getElementById("voteUp");
  const voteDown = document.getElementById("voteDown");
  const hintLike = document.getElementById("hintLike");
  const hintDislike = document.getElementById("hintDislike");

  player.muted = forceMuted;

  // Volume control
  const volumeControl = document.getElementById("volumeControl");
  const volumeBtn = document.getElementById("volumeBtn");
  const volumeSlider = document.getElementById("volumeSlider");
  const volumeKey = `clip_volume_${login}`;
  let savedVolume = parseFloat(localStorage.getItem(volumeKey) || "1");
  let isMuted = forceMuted;

  player.volume = savedVolume;
  volumeSlider.value = savedVolume * 100;

  function updateVolumeIcon() {
    if (isMuted || player.volume === 0) {
      volumeBtn.textContent = "üîá";
    } else if (player.volume < 0.5) {
      volumeBtn.textContent = "üîâ";
    } else {
      volumeBtn.textContent = "üîä";
    }
  }
  updateVolumeIcon();

  volumeBtn.addEventListener("click", () => {
    isMuted = !isMuted;
    player.muted = isMuted;
    updateVolumeIcon();
  });

  volumeSlider.addEventListener("input", (e) => {
    const vol = e.target.value / 100;
    player.volume = vol;
    savedVolume = vol;
    localStorage.setItem(volumeKey, vol.toString());
    isMuted = false;
    player.muted = false;
    updateVolumeIcon();
  });

  // Show volume control on mouse move
  let volumeHideTimeout = null;
  function showVolumeControl() {
    volumeControl.classList.add("show");
    if (volumeHideTimeout) clearTimeout(volumeHideTimeout);
    volumeHideTimeout = setTimeout(() => {
      volumeControl.classList.remove("show");
    }, 3000);
  }
  document.addEventListener("mousemove", showVolumeControl);
  document.addEventListener("click", showVolumeControl);

  // Vote button handlers
  function handleVoteClick(voteType, e) {
    e.preventDefault();
    e.stopPropagation();
    submitVote(voteType);
  }
  if ('ontouchstart' in window) {
    voteUp.addEventListener('touchend', (e) => handleVoteClick('like', e), { passive: false });
    voteDown.addEventListener('touchend', (e) => handleVoteClick('dislike', e), { passive: false });
    voteUp.addEventListener('click', (e) => e.preventDefault());
    voteDown.addEventListener('click', (e) => e.preventDefault());
  } else {
    voteUp.addEventListener('click', (e) => handleVoteClick('like', e));
    voteDown.addEventListener('click', (e) => handleVoteClick('dislike', e));
  }

  // HUD Position polling
  const hudEnabled = qs.get("hud") !== "0";
  let currentHudPosition = null;
  let currentTopPosition = null;
  const topClipsOverlay = document.getElementById("topClipsOverlay");

  function setHudPosition(pos, force = false) {
    const validPositions = ['tr', 'tl', 'br', 'bl'];
    if (!validPositions.includes(pos)) pos = 'tr';
    if (!force && pos === currentHudPosition) return;

    currentHudPosition = pos;
    voteHud.classList.remove('pos-tr', 'pos-tl', 'pos-br', 'pos-bl');
    voteHud.classList.add(`pos-${pos}`);
    console.log('[HUD] Position set to:', pos);
  }

  function setTopPosition(pos, force = false) {
    const validPositions = ['tr', 'tl', 'br', 'bl'];
    if (!validPositions.includes(pos)) pos = 'br';
    if (!force && pos === currentTopPosition) return;

    currentTopPosition = pos;
    topClipsOverlay.classList.remove('pos-tr', 'pos-tl', 'pos-br', 'pos-bl');
    topClipsOverlay.classList.add(`pos-${pos}`);
    console.log('[TOP] Position set to:', pos);
  }

  // Banner overlay
  let currentBannerJSON = null;
  let bannerFontLoaded = null;
  let bannerTimerId = null;
  let bannerTimedState = null; // tracks timed_enabled + show_duration + interval

  function setupBannerTimer(config, overlay) {
    const key = `${config.timed_enabled}|${config.show_duration}|${config.interval}`;
    if (key === bannerTimedState) return;
    bannerTimedState = key;

    if (bannerTimerId) { clearInterval(bannerTimerId); bannerTimerId = null; }

    if (!config.timed_enabled) {
      overlay.style.display = 'flex';
      overlay.style.opacity = '1';
      return;
    }

    const showMs = (config.show_duration || 15) * 1000;
    const intervalMs = (config.interval || 5) * 60 * 1000;
    const cycleMs = showMs + intervalMs;

    // Start visible
    overlay.style.display = 'flex';
    overlay.style.opacity = '1';
    overlay.style.transition = 'opacity 0.5s ease';
    let start = Date.now();

    bannerTimerId = setInterval(() => {
      const elapsed = (Date.now() - start) % cycleMs;
      if (elapsed < showMs) {
        overlay.style.display = 'flex';
        overlay.style.opacity = '1';
      } else {
        overlay.style.opacity = '0';
      }
    }, 250);
  }

  function applyBannerConfig(config) {
    const overlay = document.getElementById('bannerOverlay');
    const textEl = document.getElementById('bannerText');
    if (!overlay || !textEl) return;

    if (!config || !config.enabled) {
      overlay.style.display = 'none';
      currentBannerJSON = null;
      if (bannerTimerId) { clearInterval(bannerTimerId); bannerTimerId = null; }
      bannerTimedState = null;
      return;
    }

    const configStr = JSON.stringify(config);
    if (configStr === currentBannerJSON) return;
    currentBannerJSON = configStr;

    // Apply all visual styles first
    overlay.style.display = 'flex';
    textEl.textContent = config.text || 'Be right back!';
    console.log('[Banner] SHOWING banner -', config.text, 'position:', config.position, 'display:', overlay.style.display);

    const bgColor = config.bg_color || '#9147ff';
    const opacity = config.bg_opacity ?? 0.85;
    const r = parseInt(bgColor.slice(1,3), 16);
    const g = parseInt(bgColor.slice(3,5), 16);
    const b = parseInt(bgColor.slice(5,7), 16);
    overlay.style.background = `rgba(${r},${g},${b},${opacity})`;
    overlay.style.color = config.text_color || '#ffffff';

    const fontFamily = config.font_family || 'Inter';
    overlay.style.fontFamily = `'${fontFamily}', sans-serif`;
    overlay.style.fontSize = (config.font_size || 32) + 'px';

    if (bannerFontLoaded !== fontFamily) {
      bannerFontLoaded = fontFamily;
      const existing = document.getElementById('bannerGoogleFont');
      if (existing) existing.remove();
      const link = document.createElement('link');
      link.id = 'bannerGoogleFont';
      link.rel = 'stylesheet';
      link.href = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(fontFamily)}&display=swap`;
      document.head.appendChild(link);
    }

    overlay.classList.remove('pos-top', 'pos-center', 'pos-bottom');
    overlay.classList.add('pos-' + (config.position || 'top'));

    // Scroll animation forces full-width rectangle
    const effectiveShape = config.animation === 'scroll' ? 'rectangle' : (config.shape || 'rectangle');

    if (effectiveShape === 'pill') {
      overlay.style.borderRadius = '50px';
      overlay.style.width = 'auto';
      overlay.style.left = '50%';
      overlay.style.right = 'auto';
      overlay.style.transform = config.position === 'center' ? 'translate(-50%, -50%)' : 'translateX(-50%)';
    } else if (effectiveShape === 'rounded') {
      overlay.style.borderRadius = '12px';
      overlay.style.width = 'auto';
      overlay.style.left = '50%';
      overlay.style.right = 'auto';
      overlay.style.transform = config.position === 'center' ? 'translate(-50%, -50%)' : 'translateX(-50%)';
    } else {
      overlay.style.borderRadius = '0';
      overlay.style.width = '';
      overlay.style.left = '0';
      overlay.style.right = '0';
      overlay.style.transform = config.position === 'center' ? 'translateY(-50%)' : '';
    }

    if (config.border_style === 'solid') {
      overlay.style.border = '1px solid rgba(255,255,255,0.6)';
      overlay.style.boxShadow = 'none';
    } else if (config.border_style === 'glow') {
      overlay.style.border = 'none';
      overlay.style.boxShadow = `0 0 15px ${bgColor}, 0 0 30px ${bgColor}40`;
    } else {
      overlay.style.border = 'none';
      overlay.style.boxShadow = 'none';
    }

    if (config.animation === 'pulse') {
      textEl.style.animation = 'bannerPulse 2s ease-in-out infinite';
      textEl.style.whiteSpace = '';
    } else if (config.animation === 'scroll') {
      textEl.style.animation = `bannerScroll ${config.scroll_speed || 8}s linear infinite`;
      textEl.style.whiteSpace = 'nowrap';
    } else {
      textEl.style.animation = 'none';
      textEl.style.whiteSpace = '';
    }

    // Handle timed display cycling
    setupBannerTimer(config, overlay);
  }

  async function pollHudPosition() {
    if (!hudEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/hud_position.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (data) {
        if (data.hud_position || data.position) {
          setHudPosition(data.hud_position || data.position, currentHudPosition === null);
        }
        if (data.top_position) {
          setTopPosition(data.top_position, currentTopPosition === null);
        }
        if (data.banner_config) {
          applyBannerConfig(data.banner_config);
        }
      }
    } catch (e) {
      console.error('[HUD] Poll error:', e);
      if (currentHudPosition === null) setHudPosition('tr', true);
      if (currentTopPosition === null) setTopPosition('br', true);
    }
  }

  if (hudEnabled) {
    pollHudPosition();
    setInterval(pollHudPosition, 2000);
  }

  // Debug
  const debugEnabled = qs.get("debug") === "1";
  const debugOverlay = document.getElementById("debugOverlay");
  const debugLines = [];

  function debugLog(msg, type = "info") {
    if (!debugEnabled) return;
    const time = new Date().toLocaleTimeString("en-US", { hour12: false });
    debugLines.push({ time, msg, type });
    if (debugLines.length > 25) debugLines.shift();
    debugOverlay.classList.add("show");
    debugOverlay.innerHTML = debugLines.map(l => `<div class="${l.type}">${l.time} ${l.msg}</div>`).join("");
  }

  // State
  let clips = [];
  let voteScores = {};
  let weightingConfig = null; // Custom weighting config from streamer settings
  let currentClip = null;
  let currentSeq = null;
  let isLoggedIn = false;
  let currentUserVote = null; // 'like', 'dislike', or null
  let voteInProgress = false;
  let failedClips = new Set();
  let isSwitching = false;
  let advanceTimer = null;
  let clipHistory = []; // Stack of previously played clips for !cprev
  const MAX_HISTORY = 20;

  // Category filter state
  let categoryFilter = null; // { game_id, game_name, clip_ids: Set }
  let lastCategoryNonce = null;

  // Playlist state
  let activePlaylist = null; // { id, name, clips: [], current_index }
  let lastPlaylistId = null;

  // HUD poll interval (hudEnabled already declared above for position polling)
  const hudPollMs = parseInt(qs.get("hudpoll") || "900", 10);

  function formatDuration(s) {
    if (!s || s <= 0) return "";
    s = Math.round(s);
    return s < 60 ? `${s}s` : `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
  }

  function formatDate(d) {
    if (!d) return "";
    try {
      return new Date(d).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
    } catch { return ""; }
  }

  function updateHud(clip) {
    if (!hudEnabled || !clip) return;
    const seq = clip.seq || 0;
    voteSeq.textContent = `Clip #${seq}`;
    hintLike.textContent = `!like ${seq}`;
    hintDislike.textContent = `!dislike ${seq}`;
    clipDateHud.textContent = formatDate(clip.created_at) ? `‚Ä¢ ${formatDate(clip.created_at)}` : "";
    clipTitle.textContent = clip.title || "";

    const meta = [];
    const dur = formatDuration(clip.duration);
    if (dur) meta.push(`<span class="meta-duration">${dur}</span>`);
    if (clip.game_name) meta.push(`<span class="meta-category">${clip.game_name}</span>`);
    if (clip.creator_name) meta.push(`<span><span class="meta-clipper-label">Clipped by</span> <span class="meta-clipper-name">${clip.creator_name}</span></span>`);
    clipMeta.innerHTML = meta.join("");
    voteHud.classList.add("show");

    // Fetch auth-aware votes for this clip
    if (seq) fetchVotes(seq);
  }

  async function fetchVotes(seq) {
    if (!seq) return;
    currentSeq = seq;
    try {
      const res = await fetch(
        `${API_BASE}/api/votes.php?streamer=${encodeURIComponent(login)}&seq=${seq}`,
        { cache: "no-store", credentials: "same-origin" }
      );
      const data = await res.json();
      isLoggedIn = !!data.logged_in;

      if (data.votes && data.votes[seq]) {
        const v = data.votes[seq];
        voteUp.textContent = `üëç ${v.likes || 0}`;
        voteDown.textContent = `üëé ${v.dislikes || 0}`;
        currentUserVote = v.user_vote || null;
      } else {
        voteUp.textContent = `üëç 0`;
        voteDown.textContent = `üëé 0`;
        currentUserVote = null;
      }
      updateVoteButtonStates();
      const prompt = document.getElementById('loginPrompt');
      if (prompt) prompt.style.display = 'none';
    } catch (e) {
      // Silently fail
    }
  }

  function updateVoteButtonStates() {
    voteUp.classList.toggle('voted', currentUserVote === 'like');
    voteDown.classList.toggle('voted', currentUserVote === 'dislike');
  }

  async function submitVote(voteType) {
    if (voteInProgress || !currentSeq) return;

    if (!isLoggedIn) {
      const prompt = document.getElementById('loginPrompt');
      if (prompt) {
        prompt.style.display = 'block';
        const loginLink = document.getElementById('loginLink');
        if (loginLink) {
          loginLink.href = `${API_BASE}/auth/login.php?return=${encodeURIComponent(location.href)}`;
        }
      }
      return;
    }

    const isActive = currentUserVote === voteType;
    const newVote = isActive ? 'clear' : voteType;

    voteInProgress = true;
    voteUp.disabled = true;
    voteDown.disabled = true;

    const prevVote = currentUserVote;
    const prevUpText = voteUp.textContent;
    const prevDownText = voteDown.textContent;

    let upCount = parseInt(voteUp.textContent.replace(/[^0-9]/g, '')) || 0;
    let downCount = parseInt(voteDown.textContent.replace(/[^0-9]/g, '')) || 0;
    if (prevVote === 'like') upCount--;
    if (prevVote === 'dislike') downCount--;
    if (newVote === 'like') upCount++;
    if (newVote === 'dislike') downCount++;
    currentUserVote = newVote === 'clear' ? null : newVote;
    voteUp.textContent = `üëç ${Math.max(0, upCount)}`;
    voteDown.textContent = `üëé ${Math.max(0, downCount)}`;
    updateVoteButtonStates();

    try {
      const res = await fetch(`${API_BASE}/api/vote.php`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ streamer: login, seq: parseInt(currentSeq), vote: newVote })
      });
      const data = await res.json();

      if (data.success) {
        voteUp.textContent = `üëç ${data.likes || 0}`;
        voteDown.textContent = `üëé ${data.dislikes || 0}`;
        currentUserVote = data.user_vote || null;
        updateVoteButtonStates();
      } else {
        currentUserVote = prevVote;
        voteUp.textContent = prevUpText;
        voteDown.textContent = prevDownText;
        updateVoteButtonStates();
        if (res.status === 401) isLoggedIn = false;
      }
    } catch (e) {
      currentUserVote = prevVote;
      voteUp.textContent = prevUpText;
      voteDown.textContent = prevDownText;
      updateVoteButtonStates();
    } finally {
      voteInProgress = false;
      voteUp.disabled = false;
      voteDown.disabled = false;
    }
  }

  async function pollVotes() {
    if (!hudEnabled || !currentClip?.seq) return;
    fetchVotes(currentClip.seq);
  }

  // Persistence
  function loadState() { try { return JSON.parse(localStorage.getItem(storageKey) || "{}"); } catch { return {}; } }
  function saveState(s) { localStorage.setItem(storageKey, JSON.stringify(s)); }

  // GQL: Get MP4 URL with timeout
  async function getMp4Url(clipId) {
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 8000); // 8 second timeout

      const res = await fetch(GQL_URL, {
        method: "POST",
        headers: { "Client-ID": CLIENT_ID, "Content-Type": "application/json" },
        body: JSON.stringify({
          operationName: "VideoAccessToken_Clip",
          variables: { slug: clipId },
          extensions: { persistedQuery: { version: 1, sha256Hash: QUERY_HASH } }
        }),
        signal: controller.signal
      });
      clearTimeout(timeout);

      if (!res.ok) return null;
      const data = await res.json();
      const clip = data?.data?.clip;
      if (!clip) return null;

      const token = clip.playbackAccessToken?.value;
      const sig = clip.playbackAccessToken?.signature;
      const qualities = clip.videoQualities || [];
      if (!token || !sig || !qualities.length) return null;

      const best = qualities.sort((a,b) => (parseInt(b.quality)||0) - (parseInt(a.quality)||0))[0];
      const sep = best.sourceURL.includes("?") ? "&" : "?";
      return `${best.sourceURL}${sep}sig=${encodeURIComponent(sig)}&token=${encodeURIComponent(token)}`;
    } catch (e) {
      debugLog("GQL err: " + e.message, "err");
      return null;
    }
  }

  // Get next clip from active playlist
  function getNextPlaylistClip() {
    if (!activePlaylist || !activePlaylist.clips || !activePlaylist.clips.length) {
      return null;
    }

    const idx = activePlaylist.current_index || 0;
    if (idx >= activePlaylist.clips.length) {
      // Playlist finished
      debugLog(`Playlist "${activePlaylist.name}" finished (${activePlaylist.clips.length} clips)`, "ok");
      activePlaylist = null;
      lastPlaylistId = null;
      return null;
    }

    const playlistClip = activePlaylist.clips[idx];
    // Find this clip in our clips array by clip_id
    const clip = clips.find(c => c.id === playlistClip.clip_id);
    if (clip) {
      debugLog(`Playlist clip ${idx + 1}/${activePlaylist.clips.length}: ${clip.title?.substring(0, 30) || clip.id}`, "ok");
      activePlaylist.current_index = idx + 1;
      return clip;
    } else {
      // Clip not in pool, skip to next
      debugLog(`Playlist clip ${playlistClip.clip_id} not in pool, skipping`, "warn");
      activePlaylist.current_index = idx + 1;
      return getNextPlaylistClip();
    }
  }

  // Weighted selection
  function pickNextClip() {
    // Check if playlist mode is active
    if (activePlaylist && activePlaylist.clips && activePlaylist.clips.length > 0) {
      const playlistClip = getNextPlaylistClip();
      if (playlistClip) {
        return playlistClip;
      }
      // Playlist finished or empty, fall through to random selection
    }

    const state = loadState();
    state.recent = Array.isArray(state.recent) ? state.recent : [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};

    const recentSet = new Set(state.recent.slice(-RECENT_BLOCK));

    // Use current clips array (already filtered if category mode is active)
    let pool = clips;

    // Exclude recent and failed clips
    const candidates = pool.filter(c => !recentSet.has(c.id) && !failedClips.has(c.id));
    const usable = candidates.length ? candidates : pool.filter(c => !failedClips.has(c.id));

    if (!usable.length) {
      // All clips failed or blocked, reset failed set
      failedClips.clear();
      return clips[Math.floor(Math.random() * clips.length)];
    }

    const scored = usable.map(c => {
      const plays = state.playCounts[c.id] || 0;
      const lastAt = state.lastPlayedAt[c.id] || 0;
      const minutesAgo = (Date.now() - lastAt) / 60000;

      // Get weights (defaults if no custom config)
      const w = weightingConfig?.enabled && weightingConfig?.weights
        ? weightingConfig.weights
        : { recency: 1.0, views: 1.0, play_penalty: 1.0, voting: 1.0 };

      let score = 1;

      // Recency bonus (time since last played, scaled by weight)
      score += Math.min(5, minutesAgo / 15) * w.recency;

      // Play count penalty (scaled by weight)
      score += Math.max(0, 3 - plays) * w.play_penalty;

      // View count bonus (log scale, scaled by weight)
      const views = Number(c.view_count || 0);
      score += Math.min(1.8, Math.log10(views + 1) * 0.55) * w.views;

      // Voting bonus (scaled by weight)
      const netVotes = voteScores[c.id] || 0;
      score += Math.max(-5, Math.min(5, netVotes * 0.5)) * w.voting;

      // Apply custom boosts if weighting is enabled
      if (weightingConfig?.enabled) {
        // Duration boosts
        const dur = Number(c.duration || 30);
        const db = weightingConfig.duration_boosts || {};
        if (db.short?.enabled && dur < (db.short.max || 30)) {
          score += db.short.boost || 0;
        } else if (db.medium?.enabled && dur >= (db.medium.min || 30) && dur <= (db.medium.max || 60)) {
          score += db.medium.boost || 0;
        } else if (db.long?.enabled && dur > (db.long.min || 60)) {
          score += db.long.boost || 0;
        }

        // Category boosts
        const gameId = c.game_id || '';
        const catBoosts = weightingConfig.category_boosts || [];
        for (const cat of catBoosts) {
          if (cat.game_id === gameId) {
            score += cat.boost || 0;
            break;
          }
        }

        // Clipper boosts
        const clipper = (c.creator_name || '').toLowerCase();
        const clipperBoosts = weightingConfig.clipper_boosts || [];
        for (const cb of clipperBoosts) {
          if (cb.name === clipper) {
            score += cb.boost || 0;
            break;
          }
        }

        // Golden clips boost
        const seq = Number(c.seq || 0);
        const goldenClips = weightingConfig.golden_clips || [];
        for (const g of goldenClips) {
          if (g.seq === seq) {
            score += g.boost || 0;
            break;
          }
        }
      }

      return { c, score: Math.max(0, score) };
    }).filter(x => x.score > 0.1);

    scored.sort((a,b) => b.score - a.score);
    const top = scored.slice(0, 25);

    const total = top.reduce((s,x) => s + x.score, 0);
    let r = Math.random() * total;
    for (const x of top) { r -= x.score; if (r <= 0) return x.c; }
    return top[0]?.c || usable[0];
  }

  function markPlayed(c) {
    const state = loadState();
    state.recent = state.recent || [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};

    state.recent.push(c.id);
    if (state.recent.length > 2000) state.recent = state.recent.slice(-800);
    state.playCounts[c.id] = (state.playCounts[c.id] || 0) + 1;
    state.lastPlayedAt[c.id] = Date.now();
    saveState(state);
  }

  // Now playing
  async function setNowPlaying(c) {
    if (!c?.id) return;
    try {
      await fetch(`${API_BASE}/now_playing_set.php`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ login, clip_id: c.id, seq: c.seq, title: c.title, duration: c.duration, view_count: c.view_count })
      });
    } catch {}
  }

  // Report clip play to server for rotation tracking
  async function reportClipPlayed(c) {
    if (!c?.id) return;
    try {
      await fetch(`${API_BASE}/clip_played.php?login=${encodeURIComponent(login)}&clip_id=${encodeURIComponent(c.id)}`, {
        cache: "no-store"
      });
    } catch {}
  }

  // Play clip with robust timeout handling
  let loadTimeout = null;
  let stallTimeout = null;
  let bufferCheckInterval = null;
  let isFirstClip = true; // Track first clip for extra buffering
  let isCommandTriggered = false; // Track if playback was triggered by !pclip or !cskip

  function clearVideoTimeouts() {
    if (loadTimeout) { clearTimeout(loadTimeout); loadTimeout = null; }
    if (stallTimeout) { clearTimeout(stallTimeout); stallTimeout = null; }
    if (bufferCheckInterval) { clearInterval(bufferCheckInterval); bufferCheckInterval = null; }
  }

  let playbackStarted = false; // Track if video has actually started playing

  let stallRecoveryAttempts = 0;

  function resetStallTimer() {
    if (stallTimeout) clearTimeout(stallTimeout);
    // Only set stall timer if playback has actually started
    if (!playbackStarted) return;
    // Check every 8 seconds if video is progressing
    stallTimeout = setTimeout(() => {
      const buffered = player.buffered.length > 0 ? player.buffered.end(0) : 0;
      const currentTime = player.currentTime || 0;
      const bufferAhead = buffered - currentTime;

      if (bufferAhead > 0.5) {
        // We have buffer - video should be playing
        // Check if video is actually paused/frozen
        if (player.paused || player.readyState < 3) {
          stallRecoveryAttempts++;
          debugLog(`Stall recovery attempt ${stallRecoveryAttempts}: paused=${player.paused}, ready=${player.readyState}`, "warn");

          if (stallRecoveryAttempts >= 3) {
            // Too many recovery attempts, skip this clip
            debugLog("Too many stall recoveries, skipping", "err");
            failedClips.add(currentClip?.id);
            isSwitching = false;
            playNext();
            return;
          }

          // Force play
          player.play().catch(() => {});
        }
        debugLog(`Stall check: ${bufferAhead.toFixed(1)}s ahead, continuing`, "warn");
        resetStallTimer();
        return;
      }

      // No buffer ahead - truly stalled
      debugLog("Video stalled (no buffer), skipping", "warn");
      failedClips.add(currentClip?.id);
      isSwitching = false;
      playNext();
    }, 8000);
  }

  async function playClip(c, skipHistory = false) {
    if (!c) return;
    isSwitching = true;
    // Save current clip to history (unless going back or first clip)
    if (currentClip && !skipHistory) {
      clipHistory.push(currentClip);
      if (clipHistory.length > MAX_HISTORY) clipHistory.shift();
    }
    currentClip = c;
    playbackStarted = false; // Reset - not playing yet
    stallRecoveryAttempts = 0; // Reset recovery counter
    clearVideoTimeouts();
    debugLog(`Loading: ${c.id.substring(0,20)}...`);

    // Use preloaded URL if available for this clip
    let mp4Url = null;
    let hasPreloadedBuffer = false;
    debugLog(`Checking preload: clip=${c.id.substring(0,15)}, preloadedClip=${preloadedClip?.id?.substring(0,15) || 'null'}`);
    if (preloadedClip && preloadedClip.id === c.id && preloadedMp4Url) {
      mp4Url = preloadedMp4Url;
      // Check if preload video has buffer we can use
      if (preloadVideo && preloadVideo.buffered.length > 0) {
        hasPreloadedBuffer = true;
        const buffered = preloadVideo.buffered.end(0);
        debugLog(`Using preloaded buffer (${buffered.toFixed(1)}s)`, "ok");
      } else {
        debugLog("Using preloaded URL (no buffer)", "warn");
      }
      preloadedClip = null;
      preloadedMp4Url = null;
    } else {
      debugLog(`Preload miss - fetching fresh URL`);
      mp4Url = await getMp4Url(c.id);
      cleanupPreloadVideo(); // Clean up any stale preload
    }

    if (!mp4Url) {
      debugLog(`No MP4 for ${c.id}`, "err");
      failedClips.add(c.id);
      isSwitching = false;
      playNext();
      return;
    }

    // Clear old handlers
    player.oncanplay = null;
    player.onerror = null;
    player.onplaying = null;
    player.ontimeupdate = null;
    player.onstalled = null;
    player.onwaiting = null;
    player.onprogress = null;
    player.onloadstart = null;

    player.src = mp4Url;

    // Log loading events for debugging
    player.onloadstart = () => {
      debugLog("Load started...");
    };

    player.onprogress = () => {
      // This fires as data downloads - helps ensure loading is active
      if (player.buffered.length > 0) {
        const buffered = player.buffered.end(0);
        if (buffered > 0 && buffered < 1) {
          debugLog(`Progress: ${buffered.toFixed(2)}s`);
        }
      }
    };

    player.load();

    // Track if browser thinks it can play through without buffering
    let canPlayThroughFired = false;
    player.oncanplaythrough = () => {
      canPlayThroughFired = true;
      debugLog("canplaythrough fired", "ok");
    };

    // For first clip, wait for more buffer before playing
    const startPlayback = () => {
      clearTimeout(loadTimeout);
      loadTimeout = null;

      player.play().then(() => {
        debugLog(`Playing: ${c.title?.substring(0,30) || c.id}`, "ok");
        loadingOverlay.classList.add("hide");
        updateHud(c);
        markPlayed(c);
        setNowPlaying(c);
        reportClipPlayed(c); // Report to server for rotation tracking
        scheduleNext(c.duration || 30);
        isSwitching = false;
        isFirstClip = false;
        isCommandTriggered = false; // Reset command flag after playback starts
        playbackStarted = true; // NOW we're actually playing
        resetStallTimer();
        // Start preloading next clip immediately when playback begins
        if (!preloadedClip) {
          debugLog("Triggering immediate preload...");
          preloadNextClip();
        }
      }).catch(err => {
        debugLog(`Play err: ${err.message}`, "err");
        clearVideoTimeouts();
        failedClips.add(c.id);
        isSwitching = false;
        playNext();
      });
    };

    // Buffer requirements - keep it simple
    // - Preloaded clip: 2s (browser cache should make this fast)
    // - First clip (not preloaded): 8s buffer
    // - Command-triggered: 4s buffer
    // - Normal progression: 2s buffer
    const clipDur = c.duration || 30;
    let requiredBuffer = 2;
    if (hasPreloadedBuffer) {
      requiredBuffer = 2; // Preloaded - browser cache will help, minimal wait
    } else if (isFirstClip) {
      requiredBuffer = 8;
    } else if (isCommandTriggered) {
      requiredBuffer = 4;
    }
    debugLog(`Waiting for ${requiredBuffer}s buffer (first=${isFirstClip}, cmd=${isCommandTriggered}, preloaded=${hasPreloadedBuffer})...`);

    // Cleanup preload video after setting main player src (browser should cache the data)
    if (hasPreloadedBuffer) {
      // Small delay to let browser register the cache
      setTimeout(() => cleanupPreloadVideo(), 500);
    }
    let hasStarted = false;

    // Clear any existing buffer check
    if (bufferCheckInterval) { clearInterval(bufferCheckInterval); bufferCheckInterval = null; }

    let lastLoggedBuffer = 0;
    const checkBuffer = () => {
      if (hasStarted) return;
      if (player.buffered.length > 0) {
        const bufferedEnd = player.buffered.end(0);
        const clipDuration = c.duration || player.duration || 30;
        // readyState: 0=nothing, 1=metadata, 2=current, 3=future, 4=enough
        const readyState = player.readyState;
        // Start if we have enough buffer OR if we've buffered the entire clip
        const hasEnoughBuffer = bufferedEnd >= requiredBuffer;
        const hasFullClip = bufferedEnd >= (clipDuration - 0.5);

        // Just need readyState >= 3 (HAVE_FUTURE_DATA) to start
        const browserReady = readyState >= 3;

        if ((hasEnoughBuffer || hasFullClip) && browserReady) {
          hasStarted = true;
          clearInterval(bufferCheckInterval);
          debugLog(`Buffered: ${bufferedEnd.toFixed(1)}s (needed ${requiredBuffer}s, ready=${readyState})`, "ok");
          // On first clip without preload, wait 1s for network to stabilize
          if (isFirstClip && !hasPreloadedBuffer) {
            debugLog("Stabilizing (1s)...");
            setTimeout(() => {
              const finalBuffer = player.buffered.length > 0 ? player.buffered.end(0) : 0;
              debugLog(`Final buffer: ${finalBuffer.toFixed(1)}s`);
              // Just need 4s minimum to start
              if (finalBuffer >= 4) {
                startPlayback();
              } else {
                debugLog(`Buffer dropped to ${finalBuffer.toFixed(1)}s, re-buffering...`, "warn");
                hasStarted = false;
                bufferCheckInterval = setInterval(checkBuffer, 200);
              }
            }, 1000);
          } else {
            startPlayback();
          }
        } else {
          // Only log every 2s of buffer progress to reduce spam
          if (bufferedEnd - lastLoggedBuffer >= 2) {
            debugLog(`Buffering: ${bufferedEnd.toFixed(1)}s / ${requiredBuffer}s (ready=${readyState})`);
            lastLoggedBuffer = bufferedEnd;
          }
        }
      } else {
        // No buffer yet, log current state
        debugLog(`Waiting for buffer... (ready=${player.readyState})`);
      }
    };

    bufferCheckInterval = setInterval(checkBuffer, 200);

    // Cleanup on timeout - 20s for first clip, 15s for others
    const loadTimeoutMs = isFirstClip ? 20000 : 15000;
    debugLog(`Load timeout: ${loadTimeoutMs / 1000}s`);
    loadTimeout = setTimeout(() => {
      if (hasStarted) return;
      clearInterval(bufferCheckInterval);
      debugLog(`Load timeout for ${c.id.substring(0,15)}`, "err");
      failedClips.add(c.id);
      player.src = "";
      isSwitching = false;
      playNext();
    }, loadTimeoutMs);

    // Reset stall timer on progress
    player.ontimeupdate = () => {
      resetStallTimer();
    };

    // Handle stall/waiting events - try to recover from freezes
    let waitingCount = 0;
    let lastWaitingTime = 0;

    player.onstalled = () => {
      debugLog("Video stalling...", "warn");
    };

    player.onwaiting = () => {
      if (!playbackStarted) return; // Don't count pre-playback waiting

      waitingCount++;
      const now = Date.now();
      debugLog(`Video buffering... (count=${waitingCount})`, "warn");

      // If we've been waiting multiple times in quick succession, try to recover
      if (waitingCount >= 3 && (now - lastWaitingTime) < 5000) {
        debugLog("Multiple stalls detected, attempting recovery...", "warn");
        waitingCount = 0;

        // Try to nudge playback by seeking slightly forward
        const currentTime = player.currentTime;
        const buffered = player.buffered.length > 0 ? player.buffered.end(0) : 0;

        if (buffered > currentTime + 0.5) {
          // We have buffer ahead, try seeking to it
          player.currentTime = currentTime + 0.1;
          player.play().catch(() => {});
          debugLog(`Seeked to ${(currentTime + 0.1).toFixed(1)}s`, "warn");
        }
      }
      lastWaitingTime = now;
    };

    // Reset waiting count when video is playing smoothly
    player.onplaying = () => {
      waitingCount = 0;
    };

    player.onerror = () => {
      debugLog(`Video error, skipping`, "err");
      clearVideoTimeouts();
      failedClips.add(c.id);
      isSwitching = false;
      playNext();
    };
  }

  function playNext() {
    if (isSwitching) return;
    // Use preloaded clip if available, otherwise pick randomly
    let next = null;
    if (preloadedClip && preloadedMp4Url) {
      next = preloadedClip;
      debugLog(`Using preloaded clip: ${next.id.substring(0,15)}`, "ok");
    } else {
      next = pickNextClip();
      debugLog(`No preload, picking random: ${next?.id?.substring(0,15) || 'null'}`);
    }
    if (next) playClip(next);
  }

  function scheduleNext(duration) {
    if (advanceTimer) clearTimeout(advanceTimer);
    const d = Math.max(6, duration || 20);
    debugLog(`Next in ${d}s`);
    advanceTimer = setTimeout(() => {
      debugLog("Advancing...");
      playNext();
    }, d * 1000);
  }

  // Video ended event (backup)
  player.onended = () => {
    debugLog("Video ended");
    clearVideoTimeouts();
    if (advanceTimer) clearTimeout(advanceTimer);
    playNext();
  };

  // Force play polling - persist nonce to avoid replaying on page reload
  const pclipEnabled = qs.get("pclip") !== "0";
  const pclipNonceKey = `pclip_nonce_${login}`;
  let lastPclipNonce = localStorage.getItem(pclipNonceKey) || null;

  // Clear force play on server after we start playing it
  async function clearForcePlay() {
    try {
      await fetch(`${API_BASE}/force_play_clear.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      debugLog("Force play cleared", "ok");
    } catch {}
  }

  // Top clips overlay (topClipsOverlay already declared above for position polling)
  const topClipsList = document.getElementById("topClipsList");
  let topClipsTimeout = null;
  let lastTopNonce = null;

  function showTopClips(clips, count) {
    if (!clips || !clips.length) return;

    let html = '';
    clips.forEach((clip, i) => {
      const rankClass = i === 0 ? 'gold' : (i === 1 ? 'silver' : (i === 2 ? 'bronze' : ''));
      const rankEmoji = i === 0 ? 'ü•á' : (i === 1 ? 'ü•à' : (i === 2 ? 'ü•â' : `#${i + 1}`));
      const title = clip.title || '(untitled)';
      const shortTitle = title.length > 35 ? title.substring(0, 35) + '...' : title;

      html += `
        <div class="clip-row">
          <span class="rank ${rankClass}">${rankEmoji}</span>
          <div class="clip-info">
            <span class="clip-seq">#${clip.seq}</span>
            <span class="clip-title">${shortTitle}</span>
          </div>
          <div class="clip-votes">
            <span class="net-score">+${clip.net_score}</span>
            <span class="votes-up">üëç${clip.up_votes}</span>
            <span class="votes-down">üëé${clip.down_votes}</span>
          </div>
        </div>
      `;
    });

    topClipsList.innerHTML = html;
    topClipsOverlay.querySelector('.header').textContent = `Top ${count} Clips`;
    topClipsOverlay.classList.add('show');

    // Auto-hide after 15 seconds
    if (topClipsTimeout) clearTimeout(topClipsTimeout);
    topClipsTimeout = setTimeout(() => {
      topClipsOverlay.classList.remove('show');
    }, 15000);

    debugLog(`Showing top ${clips.length} clips`, "ok");
  }

  // Shuffle nonce tracking
  let lastShuffleNonce = null;

  // Category filter state
  let originalClips = null; // Store original clips when entering category mode

  // Preloading - fetch next clip's MP4 URL AND pre-buffer video data
  let preloadedClip = null;
  let preloadedMp4Url = null;
  let preloadVideo = null; // Hidden video element for actual buffering

  function cleanupPreloadVideo() {
    if (preloadVideo) {
      preloadVideo.pause();
      preloadVideo.src = '';
      preloadVideo.load();
      preloadVideo = null;
    }
  }

  async function preloadNextClip() {
    const next = pickNextClip();
    if (!next || next.id === currentClip?.id || next.id === preloadedClip?.id) return;

    try {
      const mp4Url = await getMp4Url(next.id);
      if (mp4Url) {
        preloadedClip = next;
        preloadedMp4Url = mp4Url;

        // Actually pre-buffer the video using a hidden video element
        cleanupPreloadVideo();
        preloadVideo = document.createElement('video');
        preloadVideo.preload = 'auto';
        preloadVideo.muted = true;
        preloadVideo.src = mp4Url;
        preloadVideo.load(); // Start buffering

        debugLog(`Preloading: ${next.id.substring(0,15)}...`);

        // Wait for some buffer before declaring ready
        await new Promise((resolve) => {
          const checkBuffer = () => {
            if (preloadVideo && preloadVideo.buffered.length > 0) {
              const buffered = preloadVideo.buffered.end(0);
              if (buffered >= 4) { // At least 4 seconds buffered
                debugLog(`Preloaded ${buffered.toFixed(1)}s`, "ok");
                resolve();
                return;
              }
            }
            // Timeout after 5 seconds regardless
            setTimeout(resolve, 100);
          };
          preloadVideo.addEventListener('progress', checkBuffer);
          preloadVideo.addEventListener('canplay', () => resolve());
          setTimeout(resolve, 5000); // Max 5s wait
        });
      }
    } catch {}
  }

  // Consolidated polling - single endpoint for all commands (reduces 7 calls to 1)
  async function pollAll() {
    try {
      let pollUrl = `${API_BASE}/poll.php?login=${encodeURIComponent(login)}`;
      if (instance) pollUrl += `&instance=${encodeURIComponent(instance)}`;
      const res = await fetch(pollUrl, { cache: "no-store" });
      const data = await res.json();

      // Handle Skip
      if (data?.skip && !isSwitching) {
        debugLog("Skip requested", "warn");
        isSwitching = true; // Set immediately to prevent race conditions
        clearVideoTimeouts();
        if (advanceTimer) clearTimeout(advanceTimer);
        isCommandTriggered = true;
        // Don't clear preload - let playNext() use it if it matches
        playNext();
        return; // Don't process other commands if skipping
      }

      // Handle Prev
      if (data?.prev && !isSwitching) {
        if (clipHistory.length === 0) {
          debugLog("No previous clip", "warn");
        } else {
          const prevClip = clipHistory.pop();
          debugLog(`Going back to: ${prevClip.title?.substring(0,20) || prevClip.id}`, "warn");
          isSwitching = true; // Set immediately to prevent race conditions
          clearVideoTimeouts();
          if (advanceTimer) clearTimeout(advanceTimer);
          isCommandTriggered = true;
          // Don't clear preload - it might still be useful for next natural advance
          playClip(prevClip, true);
          return;
        }
      }

      // Handle Force Play
      if (pclipEnabled && data?.force_play) {
        const fp = data.force_play;
        if (fp.nonce && fp.nonce !== lastPclipNonce) {
          // Ignore stale commands (older than 30 seconds)
          if (fp.set_at) {
            const age = Date.now() - new Date(fp.set_at).getTime();
            if (age > 30000) {
              lastPclipNonce = fp.nonce;
              localStorage.setItem(pclipNonceKey, fp.nonce);
              clearForcePlay();
            } else {
              lastPclipNonce = fp.nonce;
              localStorage.setItem(pclipNonceKey, fp.nonce);

              let c = clips.find(x => x.id === fp.clip_id);
              if (!c && fp.clip) c = fp.clip;
              if (c) {
                debugLog(`Force play: ${c.id.substring(0,15)}`, "warn");
                clearVideoTimeouts();
                if (advanceTimer) clearTimeout(advanceTimer);
                clearForcePlay();
                isCommandTriggered = true;
                // Don't clear preload - it might still be useful for next natural advance
                playClip(c);
                return;
              }
            }
          }
        }
      }

      // Handle Shuffle
      if (data?.shuffle && data.shuffle.nonce !== lastShuffleNonce) {
        lastShuffleNonce = data.shuffle.nonce;
        debugLog("Shuffle requested, fetching fresh pool...", "warn");

        // Clear category filter if active
        if (categoryFilter) {
          categoryFilter = null;
          lastCategoryNonce = null;
          originalClips = null;
        }

        // Fetch fresh clips with cache-bust
        const shuffleUrl = `${apiUrl}&_=${Date.now()}`;
        const clipRes = await fetch(shuffleUrl, { cache: "no-store" });
        const clipData = await clipRes.json();
        if (Array.isArray(clipData.clips) && clipData.clips.length) {
          clips = clipData.clips;
          // Clear recent history to allow any clip
          const state = loadState();
          state.recent = [];
          saveState(state);
          debugLog(`Shuffled! New pool: ${clips.length} clips`, "ok");
          // Clear preload since pool changed
          preloadedClip = null;
          preloadedMp4Url = null;
        }
      }

      // Handle Category
      const cat = data?.category;
      if (cat) {
        if (!cat.active) {
          // Category filter cleared - restore original clips
          if (categoryFilter) {
            debugLog("Category filter cleared", "ok");
            if (originalClips) {
              clips = originalClips;
              originalClips = null;
              debugLog(`Restored ${clips.length} clips`);
            }
            categoryFilter = null;
            lastCategoryNonce = null;
            preloadedClip = null;
            preloadedMp4Url = null;
          }
        } else if (cat.nonce && cat.nonce !== lastCategoryNonce) {
          lastCategoryNonce = cat.nonce;

          // Store original clips if first time entering category mode
          if (!originalClips) {
            originalClips = clips;
          }

          // Replace clips with category-specific clips from server
          if (cat.clips && cat.clips.length > 0) {
            clips = cat.clips;
            debugLog(`Category: ${cat.game_name} - loaded ${clips.length} clips`, "ok");
          } else {
            // Fallback: filter existing clips by ID
            const catIds = new Set(cat.clip_ids || []);
            clips = originalClips.filter(c => catIds.has(c.id));
            debugLog(`Category: ${cat.game_name} - filtered to ${clips.length} clips`, "ok");
          }

          categoryFilter = {
            game_id: cat.game_id,
            game_name: cat.game_name,
            clip_ids: new Set(cat.clip_ids || [])
          };

          // Clear preload since pool changed
          preloadedClip = null;
          preloadedMp4Url = null;

          // If we were in the middle of switching, skip to new category clip
          if (!isSwitching && clips.length > 0) {
            clearVideoTimeouts();
            if (advanceTimer) clearTimeout(advanceTimer);
            isCommandTriggered = true;
            playNext();
          }
        }
      }

      // Handle Top Clips
      if (data?.top_clips?.active && data.top_clips.nonce !== lastTopNonce) {
        lastTopNonce = data.top_clips.nonce;
        showTopClips(data.top_clips.clips, data.top_clips.count);
      }

      // Handle Playlist
      if (data?.playlist) {
        if (data.playlist.active && data.playlist.id !== lastPlaylistId) {
          // New playlist activated
          lastPlaylistId = data.playlist.id;
          activePlaylist = {
            id: data.playlist.id,
            name: data.playlist.name,
            clips: data.playlist.clips || [],
            current_index: data.playlist.current_index || 0,
            total: data.playlist.total || 0
          };
          debugLog(`Playlist activated: "${activePlaylist.name}" (${activePlaylist.total} clips)`, "ok");
        } else if (!data.playlist.active && activePlaylist) {
          // Playlist stopped
          debugLog(`Playlist "${activePlaylist.name}" stopped`, "warn");
          activePlaylist = null;
          lastPlaylistId = null;
        }
      } else if (activePlaylist) {
        // No playlist in response means it was stopped
        debugLog(`Playlist "${activePlaylist.name}" stopped`, "warn");
        activePlaylist = null;
        lastPlaylistId = null;
      }

      // Vote HUD now updated by fetchVotes() which uses auth-aware api/votes.php

    } catch (e) {
      debugLog("Poll error: " + e.message, "err");
    }
  }

  // Init
  async function init() {
    debugLog("Init starting...");

    // Clear any previous playback state on browser refresh
    try {
      await fetch(`${API_BASE}/clear_playback_state.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      debugLog("Playback state cleared");
    } catch (e) {
      debugLog("Could not clear state: " + e.message, "warn");
    }

    // Fetch clips
    try {
      const res = await fetch(apiUrl, { cache: "no-store" });
      const data = await res.json();
      clips = Array.isArray(data.clips) ? data.clips : [];
      debugLog(`Loaded ${clips.length} clips`, "ok");
    } catch (e) {
      debugLog("Fetch failed: " + e.message, "err");
      return;
    }

    if (!clips.length) {
      debugLog("No clips!", "err");
      return;
    }

    // Fetch votes
    try {
      const res = await fetch(`${API_BASE}/votes_export.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (Array.isArray(data.votes)) {
        data.votes.forEach(v => { voteScores[v.clip_id] = v.net_score || 0; });
        debugLog(`Loaded ${Object.keys(voteScores).length} votes`);
      }
    } catch {}

    // Fetch custom weighting config
    try {
      const res = await fetch(`${API_BASE}/dashboard_api.php?action=get_weighting_for_player&login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (data.success && data.config) {
        weightingConfig = data.config;
        debugLog(`Loaded weighting config (enabled: ${weightingConfig.enabled})`);
      }
    } catch {}

    // Preload and start first clip BEFORE starting polling
    // This ensures no poll interference during initial load
    debugLog("Preloading first clip...");
    const first = pickNextClip();
    if (first) {
      debugLog(`Selected first clip: ${first.id.substring(0,20)}...`);
      try {
        const mp4Url = await getMp4Url(first.id);
        if (mp4Url) {
          // Pre-buffer the first clip's video data
          cleanupPreloadVideo();
          preloadVideo = document.createElement('video');
          preloadVideo.preload = 'auto';
          preloadVideo.muted = true;
          preloadVideo.src = mp4Url;
          preloadVideo.load();

          debugLog("Buffering first clip...");

          // Wait for at least 8 seconds buffered (or timeout)
          await new Promise((resolve) => {
            const checkBuffer = () => {
              if (preloadVideo && preloadVideo.buffered.length > 0) {
                const buffered = preloadVideo.buffered.end(0);
                if (buffered >= 8) {
                  debugLog(`First clip buffered: ${buffered.toFixed(1)}s`, "ok");
                  resolve();
                  return;
                }
              }
            };
            preloadVideo.addEventListener('progress', checkBuffer);
            preloadVideo.addEventListener('canplaythrough', () => {
              debugLog("canplaythrough fired for preload");
              resolve();
            });
            // Check periodically
            const interval = setInterval(() => {
              if (preloadVideo && preloadVideo.buffered.length > 0) {
                const buffered = preloadVideo.buffered.end(0);
                debugLog(`Preload buffer: ${buffered.toFixed(1)}s`);
                if (buffered >= 8) {
                  clearInterval(interval);
                  resolve();
                }
              }
            }, 500);
            setTimeout(() => { clearInterval(interval); debugLog("Preload timeout", "warn"); resolve(); }, 10000);
          });

          // Set preload state AFTER buffering complete, right before playClip
          preloadedClip = first;
          preloadedMp4Url = mp4Url;
          debugLog(`First clip ready, preloadedClip.id=${first.id.substring(0,15)}`, "ok");
        }
      } catch (e) {
        debugLog(`Preload error: ${e.message}`, "err");
      }
      // Play - video data is pre-buffered
      debugLog(`Starting playClip for ${first.id.substring(0,15)}...`);
      playClip(first);
    }

    // Start polling AFTER first clip begins (prevents interference)
    // 2s interval is sufficient for mod commands while reducing server load
    setInterval(pollAll, 2000);

    // Preload next clip - check frequently and start as soon as playback begins
    // No delay - start preloading immediately when a clip starts playing
    setInterval(() => {
      if (currentClip && !preloadedClip && !isSwitching && playbackStarted) {
        debugLog("Starting preload...");
        preloadNextClip();
      }
    }, 1000); // Check every 1s for faster preload start

    // Refresh clips every 5 minutes for variety from full 14k+ catalog
    setInterval(async () => {
      try {
        const res = await fetch(apiUrl, { cache: "no-store" });
        const data = await res.json();
        if (Array.isArray(data.clips) && data.clips.length) {
          // Only update if not in category mode
          if (!categoryFilter) {
            clips = data.clips;
            debugLog(`Refreshed pool: ${clips.length} clips`);
            // Clear preload since pool refreshed
            preloadedClip = null;
            preloadedMp4Url = null;
          }
        }
      } catch {}
    }, 5 * 60 * 1000);
  }

  init();
})();
</script>
</body>
</html>
