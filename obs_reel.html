<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OBS Clip Reel</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      width: 100%;
      background: #000;
      overflow: hidden;
    }

    /* Single iframe - always full visibility, no opacity tricks */
    iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Status indicator - fades out */
    #status {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #0f0;
      font: 12px monospace;
      z-index: 9999;
      background: rgba(0,0,0,0.8);
      padding: 8px;
      border-radius: 4px;
      pointer-events: none;
      transition: opacity 0.5s;
    }

    /* Vote HUD - same styling as main reel */
    #voteHud{
      position:absolute;
      right:24px;
      top:24px;
      z-index:11000;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      padding:18px 24px;
      border-radius:16px;
      background: rgba(0,0,0,0.25);
      border: 2px solid rgba(255,255,255,0.15);
      color:#fff;
      font: 18px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      user-select:none;
      pointer-events:none;
      backdrop-filter: blur(12px);
      opacity:0;
      transform: translateX(6px);
      transition: opacity 180ms linear, transform 180ms linear;
      box-shadow: 0 4px 24px rgba(0,0,0,0.6);
      max-width:550px;
      text-align:center;
    }
    #voteHud.show{
      opacity:1;
      transform: translateX(0);
    }
    #voteHud .clip-info{
      display:flex;
      flex-direction:column;
      gap:6px;
      width:100%;
      align-items:center;
    }
    #voteHud .seq{
      font-weight:800;
      font-size:24px;
      letter-spacing:.3px;
      color:#fff;
      text-shadow: 0 2px 4px rgba(0,0,0,0.7);
    }
    #voteHud .clip-date-hud{
      font-weight:600;
      font-size:18px;
      color:#a0a0ff;
      text-shadow: 0 2px 4px rgba(0,0,0,0.7);
      margin-left:10px;
    }
    #voteHud .clip-title{
      font-weight:600;
      font-size:18px;
      color:#f0f0f0;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    #voteHud .clip-meta{
      font-size:17px;
      font-weight:600;
      color:#e8e8e8;
      display:flex;
      gap:14px;
      justify-content:center;
      flex-wrap:wrap;
      text-shadow: 0 2px 4px rgba(0,0,0,0.7);
    }
    #voteHud .clip-meta span{
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    #voteHud .meta-duration{ color:#fbbf24; }
    #voteHud .meta-category{ color:#22d3ee; }
    #voteHud .meta-clipper-label{ color:#a0a0a0; }
    #voteHud .meta-clipper-name{ color:#c084fc; }
    #voteHud .vote-section{
      display:flex;
      gap:14px;
      align-items:center;
      padding-top:8px;
      border-top: 1px solid rgba(255,255,255,0.2);
      width:100%;
      justify-content:center;
    }
    #voteHud .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:8px 14px;
      border-radius:999px;
      font-weight:700;
      font-size:18px;
    }
    #voteHud .pill.up{
      background: rgba(34,197,94,0.2);
      border: 2px solid rgba(34,197,94,0.6);
      color: #4ade80;
    }
    #voteHud .pill.down{
      background: rgba(239,68,68,0.2);
      border: 2px solid rgba(239,68,68,0.6);
      color: #f87171;
    }
    #voteHud .hints{
      display:flex;
      flex-direction:column;
      gap:3px;
      font-size:16px;
      font-weight:700;
    }
    #voteHud .hint-like{ color: #4ade80; }
    #voteHud .hint-dislike{ color: #f87171; }
  </style>
</head>
<body>
  <div id="status">Loading...</div>
  <iframe id="clip-frame" allow="autoplay; fullscreen" allowfullscreen></iframe>

  <!-- Vote HUD -->
  <div id="voteHud" aria-hidden="true">
    <div class="clip-info">
      <div style="display:flex;align-items:baseline;justify-content:center;gap:0;">
        <span class="seq" id="voteSeq">Clip</span>
        <span class="clip-date-hud" id="clipDateHud"></span>
      </div>
      <span class="clip-title" id="clipTitle"></span>
      <span class="clip-meta" id="clipMeta"></span>
    </div>
    <div class="vote-section">
      <span class="pill up" id="voteUp">üëç 0</span>
      <span class="pill down" id="voteDown">üëé 0</span>
      <div class="hints">
        <span class="hint-like" id="hintLike">!like #</span>
        <span class="hint-dislike" id="hintDislike">!dislike #</span>
      </div>
    </div>
  </div>

<script>
(async () => {
  const qs = new URLSearchParams(location.search);
  const login = (qs.get("login") || "floppyjimmie").toLowerCase();
  const parent = qs.get("parent") || location.hostname;
  const days = parseInt(qs.get("days") || "180", 10);
  const pool = parseInt(qs.get("pool") || "400", 10);

  const status = document.getElementById("status");
  const frame = document.getElementById("clip-frame");

  const API_BASE = "https://clipsystem-production.up.railway.app";
  const apiUrl = `${API_BASE}/twitch_reel_api.php?login=${encodeURIComponent(login)}&days=${days}&pool=${pool}`;

  const RECENT_BLOCK = Math.max(10, Math.floor(pool * 0.20));
  const storageKey = `away_reel_state_${login}`;

  // HUD elements
  const hudEnabled = qs.get("hud") !== "0";
  const voteHud = document.getElementById("voteHud");
  const voteSeq = document.getElementById("voteSeq");
  const clipDateHud = document.getElementById("clipDateHud");
  const clipTitle = document.getElementById("clipTitle");
  const clipMeta = document.getElementById("clipMeta");
  const voteUp = document.getElementById("voteUp");
  const voteDown = document.getElementById("voteDown");
  const hintLike = document.getElementById("hintLike");
  const hintDislike = document.getElementById("hintDislike");

  let clips = [];
  let voteScores = {};
  let currentIndex = 0;
  let currentClip = null;

  function log(msg) {
    console.log("[OBS-REEL]", msg);
    status.textContent = msg;
  }

  function clipSrc(id) {
    return `https://clips.twitch.tv/embed?clip=${encodeURIComponent(id)}&parent=${encodeURIComponent(parent)}&autoplay=true&muted=false`;
  }

  // ===== State persistence =====
  function loadState() {
    try { return JSON.parse(localStorage.getItem(storageKey) || "{}"); }
    catch { return {}; }
  }
  function saveState(state) { localStorage.setItem(storageKey, JSON.stringify(state)); }

  // ===== HUD helpers =====
  function formatDuration(seconds) {
    if (!seconds || seconds <= 0) return "";
    const s = Math.round(seconds);
    if (s < 60) return `${s}s`;
    const m = Math.floor(s / 60);
    const rem = s % 60;
    return `${m}:${rem.toString().padStart(2, '0')}`;
  }

  function formatClipDate(dateStr) {
    if (!dateStr) return "";
    try {
      const d = new Date(dateStr);
      if (isNaN(d.getTime())) return "";
      return d.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
    } catch { return ""; }
  }

  function updateHud(clip) {
    if (!hudEnabled || !clip) return;

    currentClip = clip;
    const idx = clips.findIndex(c => c.id === clip.id);
    const seq = idx >= 0 ? idx + 1 : 0;

    if (seq > 0) {
      voteSeq.textContent = `Clip #${seq}`;
      hintLike.textContent = `!like ${seq}`;
      hintDislike.textContent = `!dislike ${seq}`;

      const dateStr = formatClipDate(clip.created_at);
      clipDateHud.textContent = dateStr ? `‚Ä¢ ${dateStr}` : "";
      clipTitle.textContent = clip.title || "";

      const metaParts = [];
      const dur = formatDuration(clip.duration);
      if (dur) metaParts.push(`<span class="meta-duration">${dur}</span>`);
      if (clip.game_name) metaParts.push(`<span class="meta-category">${clip.game_name}</span>`);
      if (clip.creator_name) {
        metaParts.push(`<span><span class="meta-clipper-label">Clipped by</span> <span class="meta-clipper-name">${clip.creator_name}</span></span>`);
      }
      clipMeta.innerHTML = metaParts.join("");

      voteHud.classList.add("show");
    }
  }

  async function pollVotes() {
    if (!hudEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/vote_status.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      voteUp.textContent = `üëç ${Number(data?.up || 0)}`;
      voteDown.textContent = `üëé ${Number(data?.down || 0)}`;
    } catch {}
  }

  // ===== Clip selection with weighting =====
  const POP_WEIGHT = 0.55;
  const POP_CAP = 1.8;
  const VOTE_WEIGHT = 0.5;
  const VOTE_CAP = 5;
  function log10Safe(x) { return Math.log10 ? Math.log10(x) : (Math.log(x) / Math.LN10); }

  function pickNextClip() {
    const state = loadState();
    state.recent = Array.isArray(state.recent) ? state.recent : [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};
    state.lastGameRecent = Array.isArray(state.lastGameRecent) ? state.lastGameRecent : [];

    const recentSet = new Set(state.recent.slice(-RECENT_BLOCK));
    const recentGames = state.lastGameRecent.slice(-6);

    const candidates = clips.filter(c => !recentSet.has(c.id));
    const usable = candidates.length ? candidates : clips.slice();

    const scored = usable.map(c => {
      const plays = state.playCounts[c.id] || 0;
      const lastAt = state.lastPlayedAt[c.id] || 0;
      const minutesAgo = (Date.now() - lastAt) / 60000;

      let score = 1;
      score += Math.min(5, minutesAgo / 15);
      score += Math.max(0, 3 - plays);
      if (c.game_id && recentGames.includes(c.game_id)) score -= 2;

      const views = Number(c.view_count || 0);
      const pop = log10Safe(views + 1);
      score += Math.min(POP_CAP, pop * POP_WEIGHT);

      const netVotes = voteScores[c.id] || 0;
      score += Math.max(-VOTE_CAP, Math.min(VOTE_CAP, netVotes * VOTE_WEIGHT));

      return { c, score };
    }).filter(x => x.score > 0.1);

    scored.sort((a, b) => b.score - a.score);
    const top = scored.slice(0, Math.min(25, scored.length));

    const total = top.reduce((s, x) => s + x.score, 0);
    let r = Math.random() * total;
    for (const x of top) { r -= x.score; if (r <= 0) return x.c; }
    return top[0]?.c || clips[0];
  }

  function markPlayed(c) {
    const state = loadState();
    state.recent = Array.isArray(state.recent) ? state.recent : [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};
    state.lastGameRecent = Array.isArray(state.lastGameRecent) ? state.lastGameRecent : [];

    state.recent.push(c.id);
    if (state.recent.length > 2000) state.recent = state.recent.slice(-800);

    state.playCounts[c.id] = (state.playCounts[c.id] || 0) + 1;
    state.lastPlayedAt[c.id] = Date.now();

    if (c.game_id) {
      state.lastGameRecent.push(c.game_id);
      if (state.lastGameRecent.length > 50) state.lastGameRecent = state.lastGameRecent.slice(-20);
    }
    saveState(state);
  }

  // ===== Now playing API =====
  async function setNowPlaying(c) {
    if (!c || !c.id) return;
    try {
      const params = new URLSearchParams({ login, url: c.url || "", clip_id: c.id });
      await fetch(`${API_BASE}/now_playing_set.php?${params}`, { method: "GET", cache: "no-store" });
    } catch {}
  }

  // ===== Main playback =====
  function playClip(clip) {
    log(`Playing: ${clip.title || clip.id}`);

    // Simply set the src - no overlays, no opacity tricks
    frame.src = clipSrc(clip.id);

    markPlayed(clip);
    updateHud(clip);
    setNowPlaying(clip);

    // Schedule next clip
    const duration = Math.max(10, clip.duration || 30);
    setTimeout(() => {
      const next = pickNextClip();
      playClip(next);
    }, duration * 1000);
  }

  // ===== Force play polling (pclip) =====
  let lastPclipNonce = null;
  const pclipEnabled = qs.get("pclip") !== "0";

  async function pollPclip() {
    if (!pclipEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/force_play_get.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();

      if (!data || !data.nonce) return;
      if (data.nonce === lastPclipNonce) return;
      lastPclipNonce = data.nonce;

      // Ignore stale requests
      if (data.set_at) {
        const age = Date.now() - new Date(data.set_at).getTime();
        if (age > 60000) return;
      }

      // Find clip
      let c = clips.find(x => x.id === data.clip_id);
      if (!c && data.clip) {
        c = data.clip;
        if (!c.duration) c.duration = 30;
      }

      if (c) {
        log(`Force play: ${c.title || c.id}`);
        playClip(c);
      }
    } catch {}
  }

  // ===== Skip polling =====
  async function pollSkip() {
    try {
      const res = await fetch(`${API_BASE}/skip_check.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (data.skip) {
        log("Skip requested!");
        const next = pickNextClip();
        playClip(next);
      }
    } catch {}
  }

  // ===== Init =====
  log("Fetching clips...");

  try {
    const res = await fetch(apiUrl, { cache: "no-store" });
    const data = await res.json();
    clips = data.clips || [];

    if (clips.length === 0) {
      log("No clips found!");
      return;
    }

    log(`Loaded ${clips.length} clips`);

    // Load vote data
    try {
      const voteRes = await fetch(`${API_BASE}/votes_export.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const voteData = await voteRes.json();
      if (Array.isArray(voteData.votes)) {
        voteData.votes.forEach(v => { voteScores[v.clip_id] = v.net_score || 0; });
      }
    } catch {}

    // Start with weighted random clip
    const first = pickNextClip();
    playClip(first);

    // Fade status after a bit
    setTimeout(() => { status.style.opacity = "0"; }, 5000);

    // Start polling
    if (hudEnabled) {
      pollVotes();
      setInterval(pollVotes, 900);
    }
    if (pclipEnabled) {
      setInterval(pollPclip, 700);
    }
    setInterval(pollSkip, 1000);

    // Refresh clip list every 10 min
    setInterval(async () => {
      try {
        const r = await fetch(apiUrl, { cache: "no-store" });
        const d = await r.json();
        if (Array.isArray(d.clips) && d.clips.length) clips = d.clips;
      } catch {}
    }, 10 * 60 * 1000);

  } catch (err) {
    log("Error: " + err.message);
    console.error(err);
  }
})();
</script>
</body>
</html>
