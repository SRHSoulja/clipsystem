<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FloppyJimmie MP4 Reel</title>
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }

    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
    }

    #loadingOverlay {
      position: absolute;
      inset: 0;
      z-index: 99999;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 1;
      transition: opacity 400ms ease-out;
    }
    #loadingOverlay.hide { opacity: 0; pointer-events: none; }
    #loadingOverlay .content { text-align: center; color: #fff; font: 600 24px/1.4 system-ui, sans-serif; }
    #loadingOverlay .spinner {
      width: 48px; height: 48px; border-radius: 50%;
      border: 4px solid rgba(255,255,255,0.2); border-top-color: #fff;
      margin: 0 auto 20px; animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #voteHud {
      position: absolute;
      right: 24px;
      top: 24px;
      z-index: 11000;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      padding: 18px 24px;
      border-radius: 16px;
      background: rgba(0,0,0,0.25);
      border: 2px solid rgba(255,255,255,0.15);
      color: #fff;
      font: 18px/1.3 system-ui, sans-serif;
      backdrop-filter: blur(12px);
      opacity: 0;
      transform: translateX(6px);
      transition: opacity 180ms, transform 180ms;
      box-shadow: 0 4px 24px rgba(0,0,0,0.6);
      max-width: 550px;
      text-align: center;
      pointer-events: none;
    }
    #voteHud.show { opacity: 1; transform: translateX(0); }
    #voteHud .clip-info { display: flex; flex-direction: column; gap: 6px; width: 100%; align-items: center; }
    #voteHud .seq { font-weight: 800; font-size: 24px; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.7); }
    #voteHud .clip-date-hud { font-weight: 600; font-size: 18px; color: #a0a0ff; margin-left: 10px; }
    #voteHud .clip-title { font-weight: 600; font-size: 18px; color: #f0f0f0; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    #voteHud .clip-meta { font-size: 17px; font-weight: 600; color: #e8e8e8; display: flex; gap: 14px; justify-content: center; flex-wrap: wrap; }
    #voteHud .meta-duration { color: #fbbf24; }
    #voteHud .meta-category { color: #22d3ee; }
    #voteHud .meta-clipper-label { color: #a0a0a0; }
    #voteHud .meta-clipper-name { color: #c084fc; }
    #voteHud .vote-section { display: flex; gap: 14px; align-items: center; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); width: 100%; justify-content: center; }
    #voteHud .pill { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; border-radius: 999px; font-weight: 700; font-size: 18px; }
    #voteHud .pill.up { background: rgba(34,197,94,0.2); border: 2px solid rgba(34,197,94,0.6); color: #4ade80; }
    #voteHud .pill.down { background: rgba(239,68,68,0.2); border: 2px solid rgba(239,68,68,0.6); color: #f87171; }
    #voteHud .hints { display: flex; flex-direction: column; gap: 3px; font-size: 16px; font-weight: 700; }
    #voteHud .hint-like { color: #4ade80; }
    #voteHud .hint-dislike { color: #f87171; }

    #debugOverlay {
      position: absolute;
      right: 10px;
      bottom: 10px;
      z-index: 999999;
      background: rgba(0,0,0,0.95);
      color: #0f0;
      font: 12px/1.4 monospace;
      padding: 10px 12px;
      border-radius: 6px;
      border: 2px solid #0f0;
      max-width: 450px;
      max-height: 250px;
      overflow: hidden;
      display: none;
      pointer-events: none;
    }
    #debugOverlay.show { display: block; }
    #debugOverlay .ok { color: #4ade80; }
    #debugOverlay .err { color: #f87171; }
    #debugOverlay .warn { color: #fbbf24; }

    /* Top Clips Overlay */
    #topClipsOverlay {
      position: absolute;
      right: 24px;
      bottom: 24px;
      z-index: 12000;
      background: rgba(0,0,0,0.85);
      border: 2px solid rgba(255,215,0,0.6);
      border-radius: 16px;
      padding: 16px 20px;
      color: #fff;
      font: 16px/1.4 system-ui, sans-serif;
      backdrop-filter: blur(12px);
      box-shadow: 0 4px 24px rgba(0,0,0,0.8);
      min-width: 280px;
      max-width: 400px;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 300ms ease-out, transform 300ms ease-out;
      pointer-events: none;
    }
    #topClipsOverlay.show {
      opacity: 1;
      transform: translateY(0);
    }
    #topClipsOverlay .header {
      font-size: 20px;
      font-weight: 800;
      color: #ffd700;
      margin-bottom: 12px;
      text-align: center;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    #topClipsOverlay .clip-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    #topClipsOverlay .clip-row:last-child {
      border-bottom: none;
    }
    #topClipsOverlay .rank {
      font-size: 18px;
      font-weight: 800;
      color: #ffd700;
      min-width: 28px;
      text-align: center;
    }
    #topClipsOverlay .rank.gold { color: #ffd700; }
    #topClipsOverlay .rank.silver { color: #c0c0c0; }
    #topClipsOverlay .rank.bronze { color: #cd7f32; }
    #topClipsOverlay .clip-info {
      flex: 1;
      overflow: hidden;
    }
    #topClipsOverlay .clip-seq {
      font-weight: 700;
      color: #a0a0ff;
      margin-right: 6px;
    }
    #topClipsOverlay .clip-title {
      color: #f0f0f0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #topClipsOverlay .clip-votes {
      display: flex;
      gap: 8px;
      font-weight: 700;
      font-size: 14px;
    }
    #topClipsOverlay .votes-up { color: #4ade80; }
    #topClipsOverlay .votes-down { color: #f87171; }
    #topClipsOverlay .net-score { color: #fbbf24; font-weight: 800; }
  </style>
</head>
<body>
  <video id="player" playsinline preload="auto"></video>

  <div id="voteHud">
    <div class="clip-info">
      <div style="display:flex;align-items:baseline;justify-content:center;gap:0;">
        <span class="seq" id="voteSeq">Clip</span>
        <span class="clip-date-hud" id="clipDateHud"></span>
      </div>
      <span class="clip-title" id="clipTitle"></span>
      <span class="clip-meta" id="clipMeta"></span>
    </div>
    <div class="vote-section">
      <span class="pill up" id="voteUp">üëç 0</span>
      <span class="pill down" id="voteDown">üëé 0</span>
      <div class="hints">
        <span class="hint-like" id="hintLike">!like #</span>
        <span class="hint-dislike" id="hintDislike">!dislike #</span>
      </div>
    </div>
  </div>

  <div id="loadingOverlay">
    <div class="content">
      <div class="spinner"></div>
      <div class="text">Loading Clips...</div>
    </div>
  </div>

  <div id="debugOverlay"></div>

  <div id="topClipsOverlay">
    <div class="header">Top Clips</div>
    <div id="topClipsList"></div>
  </div>

<script>
(() => {
  const qs = new URLSearchParams(location.search);

  const login  = (qs.get("login") || "floppyjimmie").toLowerCase();
  const days   = parseInt(qs.get("days") || "0", 10);  // 0 = all time
  const pool   = parseInt(qs.get("pool") || "2000", 10);  // Large pool, reshuffled on scene reload
  const forceMuted = qs.get("muted") === "1";

  const API_BASE = "https://clipsystem-production.up.railway.app";
  const apiUrl = `${API_BASE}/twitch_reel_api.php?login=${encodeURIComponent(login)}&days=${days}&pool=${pool}`;

  // Twitch GQL for MP4 URLs
  const GQL_URL = "https://gql.twitch.tv/gql";
  const CLIENT_ID = "kimne78kx3ncx6brgo4mv6wki5h1ko";
  const QUERY_HASH = "36b89d2507fce29e5ca551df756d27c1cfe079e2609642b4390aa4c35796eb11";

  const RECENT_BLOCK = Math.max(10, Math.floor(pool * 0.20));
  const storageKey = `away_reel_state_${login}`;

  const player = document.getElementById("player");
  const loadingOverlay = document.getElementById("loadingOverlay");
  const voteHud = document.getElementById("voteHud");
  const voteSeq = document.getElementById("voteSeq");
  const clipDateHud = document.getElementById("clipDateHud");
  const clipTitle = document.getElementById("clipTitle");
  const clipMeta = document.getElementById("clipMeta");
  const voteUp = document.getElementById("voteUp");
  const voteDown = document.getElementById("voteDown");
  const hintLike = document.getElementById("hintLike");
  const hintDislike = document.getElementById("hintDislike");

  player.muted = forceMuted;

  // Debug
  const debugEnabled = qs.get("debug") === "1";
  const debugOverlay = document.getElementById("debugOverlay");
  const debugLines = [];

  function debugLog(msg, type = "info") {
    if (!debugEnabled) return;
    const time = new Date().toLocaleTimeString("en-US", { hour12: false });
    debugLines.push({ time, msg, type });
    if (debugLines.length > 25) debugLines.shift();
    debugOverlay.classList.add("show");
    debugOverlay.innerHTML = debugLines.map(l => `<div class="${l.type}">${l.time} ${l.msg}</div>`).join("");
  }

  // State
  let clips = [];
  let voteScores = {};
  let currentClip = null;
  let failedClips = new Set();
  let isSwitching = false;
  let advanceTimer = null;
  let clipHistory = []; // Stack of previously played clips for !cprev
  const MAX_HISTORY = 20;

  // Category filter state
  let categoryFilter = null; // { game_id, game_name, clip_ids: Set }
  let lastCategoryNonce = null;

  // HUD
  const hudEnabled = qs.get("hud") !== "0";
  const hudPollMs = parseInt(qs.get("hudpoll") || "900", 10);

  function formatDuration(s) {
    if (!s || s <= 0) return "";
    s = Math.round(s);
    return s < 60 ? `${s}s` : `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
  }

  function formatDate(d) {
    if (!d) return "";
    try {
      return new Date(d).toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" });
    } catch { return ""; }
  }

  function updateHud(clip) {
    if (!hudEnabled || !clip) return;
    const seq = clip.seq || 0;
    voteSeq.textContent = `Clip #${seq}`;
    hintLike.textContent = `!like ${seq}`;
    hintDislike.textContent = `!dislike ${seq}`;
    clipDateHud.textContent = formatDate(clip.created_at) ? `‚Ä¢ ${formatDate(clip.created_at)}` : "";
    clipTitle.textContent = clip.title || "";

    const meta = [];
    const dur = formatDuration(clip.duration);
    if (dur) meta.push(`<span class="meta-duration">${dur}</span>`);
    if (clip.game_name) meta.push(`<span class="meta-category">${clip.game_name}</span>`);
    if (clip.creator_name) meta.push(`<span><span class="meta-clipper-label">Clipped by</span> <span class="meta-clipper-name">${clip.creator_name}</span></span>`);
    clipMeta.innerHTML = meta.join("");
    voteHud.classList.add("show");
  }

  async function pollVotes() {
    if (!hudEnabled) return;
    try {
      const res = await fetch(`${API_BASE}/vote_status.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      voteUp.textContent = `üëç ${data?.up || 0}`;
      voteDown.textContent = `üëé ${data?.down || 0}`;
    } catch {}
  }

  // Persistence
  function loadState() { try { return JSON.parse(localStorage.getItem(storageKey) || "{}"); } catch { return {}; } }
  function saveState(s) { localStorage.setItem(storageKey, JSON.stringify(s)); }

  // GQL: Get MP4 URL with timeout
  async function getMp4Url(clipId) {
    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 8000); // 8 second timeout

      const res = await fetch(GQL_URL, {
        method: "POST",
        headers: { "Client-ID": CLIENT_ID, "Content-Type": "application/json" },
        body: JSON.stringify({
          operationName: "VideoAccessToken_Clip",
          variables: { slug: clipId },
          extensions: { persistedQuery: { version: 1, sha256Hash: QUERY_HASH } }
        }),
        signal: controller.signal
      });
      clearTimeout(timeout);

      if (!res.ok) return null;
      const data = await res.json();
      const clip = data?.data?.clip;
      if (!clip) return null;

      const token = clip.playbackAccessToken?.value;
      const sig = clip.playbackAccessToken?.signature;
      const qualities = clip.videoQualities || [];
      if (!token || !sig || !qualities.length) return null;

      const best = qualities.sort((a,b) => (parseInt(b.quality)||0) - (parseInt(a.quality)||0))[0];
      const sep = best.sourceURL.includes("?") ? "&" : "?";
      return `${best.sourceURL}${sep}sig=${encodeURIComponent(sig)}&token=${encodeURIComponent(token)}`;
    } catch (e) {
      debugLog("GQL err: " + e.message, "err");
      return null;
    }
  }

  // Weighted selection
  function pickNextClip() {
    const state = loadState();
    state.recent = Array.isArray(state.recent) ? state.recent : [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};

    const recentSet = new Set(state.recent.slice(-RECENT_BLOCK));

    // Use current clips array (already filtered if category mode is active)
    let pool = clips;

    // Exclude recent and failed clips
    const candidates = pool.filter(c => !recentSet.has(c.id) && !failedClips.has(c.id));
    const usable = candidates.length ? candidates : pool.filter(c => !failedClips.has(c.id));

    if (!usable.length) {
      // All clips failed or blocked, reset failed set
      failedClips.clear();
      return clips[Math.floor(Math.random() * clips.length)];
    }

    const scored = usable.map(c => {
      const plays = state.playCounts[c.id] || 0;
      const lastAt = state.lastPlayedAt[c.id] || 0;
      const minutesAgo = (Date.now() - lastAt) / 60000;

      let score = 1;
      score += Math.min(5, minutesAgo / 15);
      score += Math.max(0, 3 - plays);

      const views = Number(c.view_count || 0);
      score += Math.min(1.8, Math.log10(views + 1) * 0.55);

      const netVotes = voteScores[c.id] || 0;
      score += Math.max(-5, Math.min(5, netVotes * 0.5));

      return { c, score };
    }).filter(x => x.score > 0.1);

    scored.sort((a,b) => b.score - a.score);
    const top = scored.slice(0, 25);

    const total = top.reduce((s,x) => s + x.score, 0);
    let r = Math.random() * total;
    for (const x of top) { r -= x.score; if (r <= 0) return x.c; }
    return top[0]?.c || usable[0];
  }

  function markPlayed(c) {
    const state = loadState();
    state.recent = state.recent || [];
    state.playCounts = state.playCounts || {};
    state.lastPlayedAt = state.lastPlayedAt || {};

    state.recent.push(c.id);
    if (state.recent.length > 2000) state.recent = state.recent.slice(-800);
    state.playCounts[c.id] = (state.playCounts[c.id] || 0) + 1;
    state.lastPlayedAt[c.id] = Date.now();
    saveState(state);
  }

  // Now playing
  async function setNowPlaying(c) {
    if (!c?.id) return;
    try {
      await fetch(`${API_BASE}/now_playing_set.php`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ login, clip_id: c.id, seq: c.seq, title: c.title, duration: c.duration, view_count: c.view_count })
      });
    } catch {}
  }

  // Report clip play to server for rotation tracking
  async function reportClipPlayed(c) {
    if (!c?.id) return;
    try {
      await fetch(`${API_BASE}/clip_played.php?login=${encodeURIComponent(login)}&clip_id=${encodeURIComponent(c.id)}`, {
        cache: "no-store"
      });
    } catch {}
  }

  // Play clip with robust timeout handling
  let loadTimeout = null;
  let stallTimeout = null;
  let bufferCheckInterval = null;
  let isFirstClip = true; // Track first clip for extra buffering
  let isCommandTriggered = false; // Track if playback was triggered by !pclip or !cskip

  function clearVideoTimeouts() {
    if (loadTimeout) { clearTimeout(loadTimeout); loadTimeout = null; }
    if (stallTimeout) { clearTimeout(stallTimeout); stallTimeout = null; }
    if (bufferCheckInterval) { clearInterval(bufferCheckInterval); bufferCheckInterval = null; }
  }

  let playbackStarted = false; // Track if video has actually started playing

  let stallRecoveryAttempts = 0;

  function resetStallTimer() {
    if (stallTimeout) clearTimeout(stallTimeout);
    // Only set stall timer if playback has actually started
    if (!playbackStarted) return;
    // Check every 8 seconds if video is progressing
    stallTimeout = setTimeout(() => {
      const buffered = player.buffered.length > 0 ? player.buffered.end(0) : 0;
      const currentTime = player.currentTime || 0;
      const bufferAhead = buffered - currentTime;

      if (bufferAhead > 0.5) {
        // We have buffer - video should be playing
        // Check if video is actually paused/frozen
        if (player.paused || player.readyState < 3) {
          stallRecoveryAttempts++;
          debugLog(`Stall recovery attempt ${stallRecoveryAttempts}: paused=${player.paused}, ready=${player.readyState}`, "warn");

          if (stallRecoveryAttempts >= 3) {
            // Too many recovery attempts, skip this clip
            debugLog("Too many stall recoveries, skipping", "err");
            failedClips.add(currentClip?.id);
            isSwitching = false;
            playNext();
            return;
          }

          // Force play
          player.play().catch(() => {});
        }
        debugLog(`Stall check: ${bufferAhead.toFixed(1)}s ahead, continuing`, "warn");
        resetStallTimer();
        return;
      }

      // No buffer ahead - truly stalled
      debugLog("Video stalled (no buffer), skipping", "warn");
      failedClips.add(currentClip?.id);
      isSwitching = false;
      playNext();
    }, 8000);
  }

  async function playClip(c, skipHistory = false) {
    if (!c) return;
    isSwitching = true;
    // Save current clip to history (unless going back or first clip)
    if (currentClip && !skipHistory) {
      clipHistory.push(currentClip);
      if (clipHistory.length > MAX_HISTORY) clipHistory.shift();
    }
    currentClip = c;
    playbackStarted = false; // Reset - not playing yet
    stallRecoveryAttempts = 0; // Reset recovery counter
    clearVideoTimeouts();
    debugLog(`Loading: ${c.id.substring(0,20)}...`);

    const mp4Url = await getMp4Url(c.id);
    if (!mp4Url) {
      debugLog(`No MP4 for ${c.id}`, "err");
      failedClips.add(c.id);
      isSwitching = false;
      playNext();
      return;
    }

    // Clear old handlers
    player.oncanplay = null;
    player.onerror = null;
    player.onplaying = null;
    player.ontimeupdate = null;
    player.onstalled = null;
    player.onwaiting = null;
    player.onprogress = null;
    player.onloadstart = null;

    player.src = mp4Url;

    // Log loading events for debugging
    player.onloadstart = () => {
      debugLog("Load started...");
    };

    player.onprogress = () => {
      // This fires as data downloads - helps ensure loading is active
      if (player.buffered.length > 0) {
        const buffered = player.buffered.end(0);
        if (buffered > 0 && buffered < 1) {
          debugLog(`Progress: ${buffered.toFixed(2)}s`);
        }
      }
    };

    player.load();

    // Track if browser thinks it can play through without buffering
    let canPlayThroughFired = false;
    player.oncanplaythrough = () => {
      canPlayThroughFired = true;
      debugLog("canplaythrough fired", "ok");
    };

    // For first clip, wait for more buffer before playing
    const startPlayback = () => {
      clearTimeout(loadTimeout);
      loadTimeout = null;

      player.play().then(() => {
        debugLog(`Playing: ${c.title?.substring(0,30) || c.id}`, "ok");
        loadingOverlay.classList.add("hide");
        updateHud(c);
        markPlayed(c);
        setNowPlaying(c);
        reportClipPlayed(c); // Report to server for rotation tracking
        scheduleNext(c.duration || 30);
        isSwitching = false;
        isFirstClip = false;
        isCommandTriggered = false; // Reset command flag after playback starts
        playbackStarted = true; // NOW we're actually playing
        resetStallTimer();
      }).catch(err => {
        debugLog(`Play err: ${err.message}`, "err");
        clearVideoTimeouts();
        failedClips.add(c.id);
        isSwitching = false;
        playNext();
      });
    };

    // Buffer requirements:
    // - First clip (scene init): 12s max buffer (60% of clip)
    // - Command-triggered (!pclip, !cskip): 5s buffer
    // - Normal progression: 2s buffer
    const clipDur = c.duration || 30;
    let requiredBuffer = 2;
    if (isFirstClip) {
      // For first clip, buffer 12s max (or 60% for short clips)
      requiredBuffer = Math.min(clipDur * 0.6, 12);
    } else if (isCommandTriggered) {
      requiredBuffer = 5;
    }
    debugLog(`Waiting for ${requiredBuffer}s buffer (first=${isFirstClip}, cmd=${isCommandTriggered})...`);
    let hasStarted = false;

    // Clear any existing buffer check
    if (bufferCheckInterval) { clearInterval(bufferCheckInterval); bufferCheckInterval = null; }

    let lastLoggedBuffer = 0;
    const checkBuffer = () => {
      if (hasStarted) return;
      if (player.buffered.length > 0) {
        const bufferedEnd = player.buffered.end(0);
        const clipDuration = c.duration || player.duration || 30;
        // readyState: 0=nothing, 1=metadata, 2=current, 3=future, 4=enough
        const readyState = player.readyState;
        // Start if we have enough buffer OR if we've buffered the entire clip
        const hasEnoughBuffer = bufferedEnd >= requiredBuffer;
        const hasFullClip = bufferedEnd >= (clipDuration - 0.5);

        // For first clip, require canplaythrough OR readyState 4 OR enough buffer
        // Some browsers don't fire canplaythrough reliably
        const browserReady = isFirstClip
          ? (canPlayThroughFired || readyState >= 4 || bufferedEnd >= requiredBuffer)
          : (readyState >= 3);

        if ((hasEnoughBuffer || hasFullClip) && browserReady) {
          hasStarted = true;
          clearInterval(bufferCheckInterval);
          debugLog(`Buffered: ${bufferedEnd.toFixed(1)}s (needed ${requiredBuffer}s, ready=${readyState})`, "ok");
          // On first clip, wait extra time for network to stabilize
          if (isFirstClip) {
            debugLog("Stabilizing (3s)...");
            setTimeout(() => {
              const finalBuffer = player.buffered.length > 0 ? player.buffered.end(0) : 0;
              debugLog(`Final buffer: ${finalBuffer.toFixed(1)}s`);
              // Re-verify buffer is still sufficient before playing (need at least 8s)
              const minBufferToPlay = Math.min(8, requiredBuffer);
              if (finalBuffer >= minBufferToPlay) {
                startPlayback();
              } else {
                debugLog(`Buffer dropped to ${finalBuffer.toFixed(1)}s, re-buffering...`, "warn");
                hasStarted = false;
                bufferCheckInterval = setInterval(checkBuffer, 200);
              }
            }, 3000);
          } else {
            startPlayback();
          }
        } else {
          // Only log every 2s of buffer progress to reduce spam
          if (bufferedEnd - lastLoggedBuffer >= 2) {
            debugLog(`Buffering: ${bufferedEnd.toFixed(1)}s / ${requiredBuffer}s (ready=${readyState})`);
            lastLoggedBuffer = bufferedEnd;
          }
        }
      } else {
        // No buffer yet, log current state
        debugLog(`Waiting for buffer... (ready=${player.readyState})`);
      }
    };

    bufferCheckInterval = setInterval(checkBuffer, 200);

    // Cleanup on timeout - dynamic based on buffer requirement + overhead
    // First clip: requiredBuffer + 3s stabilization + 10s network overhead
    // Others: 15s fixed
    const loadTimeoutMs = isFirstClip ? (requiredBuffer + 3 + 10) * 1000 : 15000;
    debugLog(`Load timeout: ${loadTimeoutMs / 1000}s`);
    loadTimeout = setTimeout(() => {
      if (hasStarted) return;
      clearInterval(bufferCheckInterval);
      debugLog(`Load timeout for ${c.id.substring(0,15)}`, "err");
      failedClips.add(c.id);
      player.src = "";
      isSwitching = false;
      playNext();
    }, loadTimeoutMs);

    // Reset stall timer on progress
    player.ontimeupdate = () => {
      resetStallTimer();
    };

    // Handle stall/waiting events - try to recover from freezes
    let waitingCount = 0;
    let lastWaitingTime = 0;

    player.onstalled = () => {
      debugLog("Video stalling...", "warn");
    };

    player.onwaiting = () => {
      if (!playbackStarted) return; // Don't count pre-playback waiting

      waitingCount++;
      const now = Date.now();
      debugLog(`Video buffering... (count=${waitingCount})`, "warn");

      // If we've been waiting multiple times in quick succession, try to recover
      if (waitingCount >= 3 && (now - lastWaitingTime) < 5000) {
        debugLog("Multiple stalls detected, attempting recovery...", "warn");
        waitingCount = 0;

        // Try to nudge playback by seeking slightly forward
        const currentTime = player.currentTime;
        const buffered = player.buffered.length > 0 ? player.buffered.end(0) : 0;

        if (buffered > currentTime + 0.5) {
          // We have buffer ahead, try seeking to it
          player.currentTime = currentTime + 0.1;
          player.play().catch(() => {});
          debugLog(`Seeked to ${(currentTime + 0.1).toFixed(1)}s`, "warn");
        }
      }
      lastWaitingTime = now;
    };

    // Reset waiting count when video is playing smoothly
    player.onplaying = () => {
      waitingCount = 0;
    };

    player.onerror = () => {
      debugLog(`Video error, skipping`, "err");
      clearVideoTimeouts();
      failedClips.add(c.id);
      isSwitching = false;
      playNext();
    };
  }

  function playNext() {
    if (isSwitching) return;
    const next = pickNextClip();
    if (next) playClip(next);
  }

  function scheduleNext(duration) {
    if (advanceTimer) clearTimeout(advanceTimer);
    const d = Math.max(6, duration || 20);
    debugLog(`Next in ${d}s`);
    advanceTimer = setTimeout(() => {
      debugLog("Advancing...");
      playNext();
    }, d * 1000);
  }

  // Video ended event (backup)
  player.onended = () => {
    debugLog("Video ended");
    clearVideoTimeouts();
    if (advanceTimer) clearTimeout(advanceTimer);
    playNext();
  };

  // Force play polling - persist nonce to avoid replaying on page reload
  const pclipEnabled = qs.get("pclip") !== "0";
  const pclipNonceKey = `pclip_nonce_${login}`;
  let lastPclipNonce = localStorage.getItem(pclipNonceKey) || null;

  // Clear force play on server after we start playing it
  async function clearForcePlay() {
    try {
      await fetch(`${API_BASE}/force_play_clear.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      debugLog("Force play cleared", "ok");
    } catch {}
  }

  async function pollForcePlay() {
    if (!pclipEnabled) return;

    try {
      const res = await fetch(`${API_BASE}/force_play_get.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (!data || !data.nonce || data.nonce === lastPclipNonce) return;

      // Ignore stale commands (older than 30 seconds)
      if (data.set_at) {
        const age = Date.now() - new Date(data.set_at).getTime();
        if (age > 30000) {
          // Mark as seen and clear from server
          lastPclipNonce = data.nonce;
          localStorage.setItem(pclipNonceKey, data.nonce);
          clearForcePlay();
          return;
        }
      }

      lastPclipNonce = data.nonce;
      localStorage.setItem(pclipNonceKey, data.nonce);

      let c = clips.find(x => x.id === data.clip_id);
      if (!c && data.clip) c = data.clip;
      if (!c) return;

      debugLog(`Force play: ${c.id.substring(0,15)}`, "warn");
      clearVideoTimeouts();
      if (advanceTimer) clearTimeout(advanceTimer);

      // Clear the force play from server immediately so it doesn't replay
      clearForcePlay();

      // Mark as command-triggered for extra buffering
      isCommandTriggered = true;
      playClip(c);
    } catch {}
  }

  // Skip polling
  async function pollSkip() {
    if (isSwitching) return;
    try {
      const res = await fetch(`${API_BASE}/skip_check.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (data?.skip) {
        debugLog("Skip requested", "warn");
        clearVideoTimeouts();
        if (advanceTimer) clearTimeout(advanceTimer);
        // Mark as command-triggered for extra buffering
        isCommandTriggered = true;
        playNext();
      }
    } catch {}
  }

  // Prev polling (go back to previous clip)
  async function pollPrev() {
    if (isSwitching) return;
    try {
      const res = await fetch(`${API_BASE}/prev_check.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (data?.prev) {
        if (clipHistory.length === 0) {
          debugLog("No previous clip", "warn");
          return;
        }
        const prevClip = clipHistory.pop();
        debugLog(`Going back to: ${prevClip.title?.substring(0,20) || prevClip.id}`, "warn");
        clearVideoTimeouts();
        if (advanceTimer) clearTimeout(advanceTimer);
        // Mark as command-triggered for extra buffering
        isCommandTriggered = true;
        // Play previous clip, skip adding to history (we're going back)
        playClip(prevClip, true);
      }
    } catch {}
  }

  // Top clips overlay
  const topClipsOverlay = document.getElementById("topClipsOverlay");
  const topClipsList = document.getElementById("topClipsList");
  let topClipsTimeout = null;
  let lastTopNonce = null;

  function showTopClips(clips, count) {
    if (!clips || !clips.length) return;

    let html = '';
    clips.forEach((clip, i) => {
      const rankClass = i === 0 ? 'gold' : (i === 1 ? 'silver' : (i === 2 ? 'bronze' : ''));
      const rankEmoji = i === 0 ? 'ü•á' : (i === 1 ? 'ü•à' : (i === 2 ? 'ü•â' : `#${i + 1}`));
      const title = clip.title || '(untitled)';
      const shortTitle = title.length > 35 ? title.substring(0, 35) + '...' : title;

      html += `
        <div class="clip-row">
          <span class="rank ${rankClass}">${rankEmoji}</span>
          <div class="clip-info">
            <span class="clip-seq">#${clip.seq}</span>
            <span class="clip-title">${shortTitle}</span>
          </div>
          <div class="clip-votes">
            <span class="net-score">+${clip.net_score}</span>
            <span class="votes-up">üëç${clip.up_votes}</span>
            <span class="votes-down">üëé${clip.down_votes}</span>
          </div>
        </div>
      `;
    });

    topClipsList.innerHTML = html;
    topClipsOverlay.querySelector('.header').textContent = `Top ${count} Clips`;
    topClipsOverlay.classList.add('show');

    // Auto-hide after 15 seconds
    if (topClipsTimeout) clearTimeout(topClipsTimeout);
    topClipsTimeout = setTimeout(() => {
      topClipsOverlay.classList.remove('show');
    }, 15000);

    debugLog(`Showing top ${clips.length} clips`, "ok");
  }

  async function pollTopClips() {
    try {
      const res = await fetch(`${API_BASE}/ctop_check.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (data?.active && data.nonce !== lastTopNonce) {
        lastTopNonce = data.nonce;
        showTopClips(data.clips, data.count);
      }
    } catch {}
  }

  // Category filter polling
  let originalClips = null; // Store original clips when entering category mode

  async function pollCategory() {
    try {
      const res = await fetch(`${API_BASE}/category_get.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();

      if (!data?.active) {
        // Category filter cleared - restore original clips
        if (categoryFilter) {
          debugLog("Category filter cleared", "ok");
          if (originalClips) {
            clips = originalClips;
            originalClips = null;
            debugLog(`Restored ${clips.length} clips`);
          }
          categoryFilter = null;
          lastCategoryNonce = null;
        }
        return;
      }

      // Check if this is a new category command
      if (data.nonce && data.nonce !== lastCategoryNonce) {
        lastCategoryNonce = data.nonce;

        // Store original clips if first time entering category mode
        if (!originalClips) {
          originalClips = clips;
        }

        // Replace clips with category-specific clips from server
        if (data.clips && data.clips.length > 0) {
          clips = data.clips;
          debugLog(`Category: ${data.game_name} - loaded ${clips.length} clips`, "ok");
        } else {
          // Fallback: filter existing clips by ID
          const catIds = new Set(data.clip_ids || []);
          clips = originalClips.filter(c => catIds.has(c.id));
          debugLog(`Category: ${data.game_name} - filtered to ${clips.length} clips`, "ok");
        }

        categoryFilter = {
          game_id: data.game_id,
          game_name: data.game_name,
          clip_ids: new Set(data.clip_ids || [])
        };

        // If we were in the middle of switching, skip to new category clip
        if (!isSwitching && clips.length > 0) {
          clearVideoTimeouts();
          if (advanceTimer) clearTimeout(advanceTimer);
          isCommandTriggered = true;
          playNext();
        }
      }
    } catch {}
  }

  // Init
  async function init() {
    debugLog("Init starting...");

    // Fetch clips
    try {
      const res = await fetch(apiUrl, { cache: "no-store" });
      const data = await res.json();
      clips = Array.isArray(data.clips) ? data.clips : [];
      debugLog(`Loaded ${clips.length} clips`, "ok");
    } catch (e) {
      debugLog("Fetch failed: " + e.message, "err");
      return;
    }

    if (!clips.length) {
      debugLog("No clips!", "err");
      return;
    }

    // Fetch votes
    try {
      const res = await fetch(`${API_BASE}/votes_export.php?login=${encodeURIComponent(login)}`, { cache: "no-store" });
      const data = await res.json();
      if (Array.isArray(data.votes)) {
        data.votes.forEach(v => { voteScores[v.clip_id] = v.net_score || 0; });
        debugLog(`Loaded ${Object.keys(voteScores).length} votes`);
      }
    } catch {}

    // Start polling first, let page stabilize before playing
    if (hudEnabled) {
      pollVotes();
      setInterval(pollVotes, hudPollMs);
    }
    setInterval(pollForcePlay, 700);
    setInterval(pollSkip, 1000);
    setInterval(pollPrev, 1000); // Poll for !cprev
    setInterval(pollTopClips, 2000); // Poll for !ctop
    setInterval(pollCategory, 2000); // Poll category every 2s

    // Delay first clip to let page fully initialize and network stabilize
    debugLog("Waiting 4s for page to stabilize...");
    setTimeout(() => {
      debugLog("Starting first clip...");
      const first = pickNextClip();
      if (first) playClip(first);
    }, 4000);

    // Refresh clips periodically
    setInterval(async () => {
      try {
        const res = await fetch(apiUrl, { cache: "no-store" });
        const data = await res.json();
        if (Array.isArray(data.clips) && data.clips.length) clips = data.clips;
      } catch {}
    }, 10 * 60 * 1000);
  }

  init();
})();
</script>
</body>
</html>
